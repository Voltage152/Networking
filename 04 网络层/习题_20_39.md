#### P20 假定在源主机和目的主机 B 之间的数据报被限制为 1500 字节（包括首部）。假设 IP 首部为 20 字节，要发送一个 5 MB组成的 MP3 需要多少个数据报？解释你的答案是如何计算的。

  * 即每个数据报中的数据长度为 1480，那么每个应用层数据的长度为 1460，因此总共有 `5000000 / 1460 = 3425`

#### P21 考虑在图 4-22 中建立的网络。假定 ISP 此时为路由器分配地址 24.34.112.235 以及家庭网络的网络地址是 192.168.1/24。
#### a. 在家庭网络中为所有接口分配地址
#### b. 假定每台主机具有两个进行中的 TCP 连接，所有都是对主机 128.119.40.86 的 80 端口的。在 NAT 转换表中提供 6 个对应表项。

  * a.
    
    |接口|IP地址|
    |:---:|:---:|
    |路由器接口| `192.168.1.1`|
    |第一台主机| `192.168.1.2`|
    |第二台主机| `192.168.1.3`|
    |第三台主机| `192.168.1.4`|
  
  * b.
    
    |NAT 转换表|WAN端|LAN端|
    |:---:|:--:|:---:|
    |A|`24.34.112.235, 1000`| `192.168.1.2, 4000` |
    |A|`24.34.112.235, 1001`| `192.168.1.2, 4001` |
    |B|`24.34.112.235, 1002`| `192.168.1.2, 4002` |
    |B|`24.34.112.235, 1003`| `192.168.1.2, 4003` |
    |C|`24.34.112.235, 1004`| `192.168.1.2, 4004` |
    |C|`24.34.112.235, 1005`| `192.168.1.2, 4005` |

#### P22 假设你有兴趣检测 NAT 后面的主机数量。你观察到在每个 IP 分组上 IP 层顺序地标出一个标示号。由一台主机生成的第一个 IP 分组的标示号是一个随机数，后继 IP 分组的标示号是顺序分配的。假设由 NAT 后面主机产生的所有 IP 分组都发往外部。
#### a. 基于这个观察，假定你能够俘获由 NAT 向外部发送的所有分组，你能概要给出一种简单的技术来检测 NAT 后面不同主机的数量吗？评估你的答案。
#### b. 如果标示号不是顺序分配而是随机分配的，这种技术还能正常工作吗？评估你的答案。

  * a.
    * 意思是每台主机进行 IP 分片时，为 IP 数据报选择的 2 字节标示是一个随机值，第一个报文的所有分片都是该随机值，第二个报文的所有分片是该随机值加 1，由于每台主机都是选一个随机的初始值，但随后的分组都是连续递增的，所以将这些切片划分为连续递增的多个簇，最后统计簇的数量，就是 NAT 后面主机的数量。
   
  * b.
    * 不能，因为无法统计连续递增的标示号的数量了。

#### P23 在这个习题中，我们将探讨 NAT 对 P2P 应用程序的影响。假定具有用户名 Arnold 的对等方通过查询发现，具有用户名 Bernard 的对等方有一个要下载的文件。同时假定 Bernard 和 Arnold 都位于 NAT 后面。尝试设计一种技术，使得 Arnold 与 Bernard 创建一条 TCP 连接，而不对 NAT 做应用特定的配置。如果你难以设计这样的技术，试讨论原因。

  * 如果不对 NAT 做应用特定的配置，那么直接 TCP 连接两个 NAT 后面的主机是无法做到的。因为你不知道每个 NAT 端口映射的规则。如果可以对 NAT 做应用特定的配置的话，那么只需要双方约定一个端口映射，那么就可以完成两个 NAT 后面的主机的 TCP 连接。

#### P24 观察图 4-27，列举从 y 到 u 不包含任何环路的路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p24.png)

  * 第一跳是 x
    * y - x - u
    * y - x - v - u
    * y - x - w - u
    * y - x - v - w - u
  
  * 第一跳是 w
    * y - w - u
    * y - w - v - u
    * y - w - x - u
    * y - w - x - v - u
  
  * 第一跳是 z
    * y - z - w - u
    * y - z - w - v - u
    * y - z - w - x - u
    * y - z - w - x - v - u


#### P25 重复习题 P24，列举从 x 到 z, z 到 u 以及 z 到 w 的不包含任何环路的路径。

  * x 到 z
    * 第一跳是 u
      * x - u - w - z
      * x - u - w - y - z
      * x - u - w - x - y - z
      * x - u - w - v - x - y - z
      * x - u - v - w - z
      * x - u - v - w - y - z
    * 第一跳是 v
      * x - v - u - w - z
      * x - v - u - w - y - z
      * x - v - u - w - x - y - z
      * x - v - w - z
      * x - v - w - y - z
    * 第一跳是 w
      * x - w - z
      * x - w - y - z
    * 第一跳是 y
      * x - y - z
      * x - y - w - z

  * z 到 u
    * 第一跳是 w
      * z - w - u
      * z - w - v - u
      * z - w - v - x - u
      * z - w - y - x - u
      * z - w - y - x - v - u
      * z - w - x - u
      * z - w - x - v - u
    * 第一跳是 y
      * z - y - w - u
      * z - y - w - v - u
      * z - y - w - v - x - u
      * z - y - w - x - u 
      * z - y - w - x - v - u
      * z - y - x - u
      * z - y - x - v - u
      * z - y - x - v - w - u
      * z - y - x - w - u
      * z - y - x - w - v - u

  * z 到 w
    * z - w
    * 第一跳是 y
      * z - y - w
      * z - y - x - w
      * z - y - x - v - w
      * z - y - x - v - u - w
      * z - y - x - u - w
      * z - y - x - u - v - w

#### P26 考虑下面的网络。对于标明的链路费用，用 Dijkstra 的最短路径算法计算出从 x 到所有网络结点的最短路径。通过计算一个类似于表 4-3 的表，说明该算法是如何工作的。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.1.png)

  * [Dijkstra 算法实现](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p26.c) 程序运行验证如下所示 : 
  
     ~~~
     ➜  progs git:(master) ✗ ./run.sh p26.c
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from x to z : [distance = 8] { z x 8 } 
		shortest path from x to y : [distance = 6] { y x 6 } 
		shortest path from x to v : [distance = 3] { v x 3 } 
		shortest path from x to t : [distance = 7] { v x 3 }  { v t 4 } 
		shortest path from x to x : [distance = 0]
		shortest path from x to w : [distance = 6] { x w 6 } 
		shortest path from x to u : [distance = 6] { v x 3 }  { v u 3 } 
     ~~~

#### P27 考虑习题 P26 中所示的网络。使用 Dijkstra 算法和一个类似于表 4-3 的表来说明你做的工作:
#### a. 计算出从 t 到所有网络结点的最短路径。
#### b. 计算出从 u 到所有网络结点的最短路径。
#### c. 计算出从 v 到所有网络结点的最短路径。
#### d. 计算出从 w 到所有网络结点的最短路径。
#### e. 计算出从 y 到所有网络结点的最短路径。
#### f. 计算出从 z 到所有网络结点的最短路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

* [Dijkstra 算法实现](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p26.c) 程序运行结果如下所示 : 

   * a.
 
     ~~~C
	 ➜  progs git:(master) ✗ ./p26.c.exe t
		[22:37:15:13556] src = t 3
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from t to z : [distance = 15] { v t 4 }  { v x 3 }  { z x 8 } 
		shortest path from t to y : [distance = 7] { y t 7 } 
		shortest path from t to v : [distance = 4] { v t 4 } 
		shortest path from t to t : [distance = 0]
		shortest path from t to x : [distance = 7] { v t 4 }  { v x 3 } 
		shortest path from t to w : [distance = 5] { u t 2 }  { u w 3 } 
		shortest path from t to u : [distance = 2] { u t 2 } 
     ~~~
     
   * b.
   
      ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe u
		[22:38:43:827442] src = u 6
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from u to z : [distance = 14] { v u 3 }  { v x 3 }  { z x 8 } 
		shortest path from u to y : [distance = 9] { u t 2 }  { y t 7 } 
		shortest path from u to v : [distance = 3] { v u 3 } 
		shortest path from u to t : [distance = 2] { u t 2 } 
		shortest path from u to x : [distance = 6] { v u 3 }  { v x 3 } 
		shortest path from u to w : [distance = 3] { u w 3 } 
		shortest path from u to u : [distance = 0]
      ~~~
      
   * c.

	   ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe v
		[22:40:27:606071] src = v 2
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from v to z : [distance = 11] { v x 3 }  { z x 8 } 
		shortest path from v to y : [distance = 8] { y v 8 } 
		shortest path from v to v : [distance = 0]
		shortest path from v to t : [distance = 4] { v t 4 } 
		shortest path from v to x : [distance = 3] { v x 3 } 
		shortest path from v to w : [distance = 4] { v w 4 } 
		shortest path from v to u : [distance = 3] { v u 3 }
	   ~~~
   
   * d.

	   ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe w
		[22:41:22:309333] src = w 5
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from w to z : [distance = 14] { x w 6 }  { z x 8 } 
		shortest path from w to y : [distance = 12] { v w 4 }  { y v 8 } 
		shortest path from w to v : [distance = 4] { v w 4 } 
		shortest path from w to t : [distance = 5] { u w 3 }  { u t 2 } 
		shortest path from w to x : [distance = 6] { x w 6 } 
		shortest path from w to w : [distance = 0]
		shortest path from w to u : [distance = 3] { u w 3 } 
	   ~~~
   
   * e.
   
	   ~~~
	   ➜  progs git:(master) ✗ ./p26.c.exe y
		[22:42:1:378307] src = y 1
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from y to z : [distance = 12] { z y 12 } 
		shortest path from y to y : [distance = 0]
		shortest path from y to v : [distance = 8] { y v 8 } 
		shortest path from y to t : [distance = 7] { y t 7 } 
		shortest path from y to x : [distance = 6] { y x 6 } 
		shortest path from y to w : [distance = 12] { y x 6 }  { x w 6 } 
		shortest path from y to u : [distance = 9] { y t 7 }  { u t 2 } 
	   ~~~
   
   * f.

	   ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe z
		[22:42:44:217028] src = z 0
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from z to z : [distance = 0]
		shortest path from z to y : [distance = 12] { z y 12 } 
		shortest path from z to v : [distance = 11] { z x 8 }  { v x 3 } 
		shortest path from z to t : [distance = 15] { z x 8 }  { v x 3 }  { v t 4 } 
		shortest path from z to x : [distance = 8] { z x 8 } 
		shortest path from z to w : [distance = 14] { z x 8 }  { x w 6 } 
		shortest path from z to u : [distance = 14] { z x 8 }  { v x 3 }  { v u 3 }
	   ~~~
     
#### P28 考虑下图所示的网络，假设每个结点初始时知道到它每个邻居的费用。考虑距离向量算法，并显示在结点 z 中的距离表表项。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p28.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p28.1.png)

#### P29 考虑一个一般性拓扑（即不是以上所显示的特定网络）和一个同步版本的距离向量算法。假设每次迭代时，一个结点与其邻居交换其距离向量并接受它们的距离向量。假定算法开始时，每个结点只知道其直接邻居的费用，在该分布式算法收敛前所需的最大迭代次数是多少？评估你的答案。

  * 对于一个同步版本的距离向量算法有 4 个结点 A - B - C - D，在第一次交换彼此的距离向量后，A 知道了到 C 两跳的最短路径，这是 B 告诉它的。C 知道了到达 A 两跳的最短路径，这是 B 告诉它的，B 知道了到达 D 两跳的最短路径，这是 C 告诉它的。但是 A 不知道如何到 D，D 也是如此。在下一次交换距离向量后，所有结点都知道了如何到达彼此的信息。因为 B 知道如何到 D，B 告诉了 A，因此 A 知道了如何到 D。因此，假设 A 是 B 的邻居，在 B 向它的所有邻居交换了一次距离向量后，所有 B 的邻居都知道了到 A 的一跳或者两跳的最短路径。因此假设图的 "直径" 为 d，那么在迭代 d - 1 次后，所有结点都知道如何抵达彼此，那么算法将开始收敛。 

#### P30 考虑下图所示的网络段。x 只有两个相连邻居 w 与 y。w 有一条通向目的地 u (没有显示)的最低费用路径，其值为 5；y 有一条通向目的地 u 的最低费用路径，其值为 6。从 w 与 y 到 u (以及 w 与 y 之间)的完整路径没有显示出来。网络中所有链路费用皆为正整数。
#### a. 给出 x 对目的地 w, y 和 u 的距离向量
#### b. 给出对 c(x, w) 或 c(x, y) 的链路费用的变化，使得执行了距离向量算法后，x 将通知其邻居有一条通向 u 的新最低费用路径。
#### c. 给出对 c(x, w) 或 c(x, y) 的链路费用的变化，使得执行了距离向量算法后，x 将不通知其邻居有一条通向 u 的新最低费用路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p30.png)

  * a.
    * Dx(w) = 2，Dx(y) = 4, Dx(u) = 7
    
  * b.
    * 现在到 u 的路径为 x - w - u
    * 考虑如果减小 c(x, y)，那么即使 c(x, y) = 1，最小费用的路径仍然是 x - w - u = 7，所以减小当前链路中的费用，不会改变最小费用路径
    * 考虑增大链路的费用，当 c(x, w) 增加到 7 时，Dx(u) = min{7 + 5, 5 + 6} = 11，因此 x 将通知其邻居有一条通向 u 的新最低费用路径。
    
  * c.
    * 保证 c(x, w) 在小于 7 范围内的增加，以及减少 c(x, w) 或减少 c(x, y) 都不会改变 x 到 u 的最低费用路径。

#### P31 考虑如图 4-30 中所示的 3 个结点的拓扑。不使用显示在图 4-30 中的费用值，链路费用值现在是 c(x, y) = 3, c(y, z) = 6, c(z, x) = 4。在距离向量表初始化后和在同步版本的距离向量算法每次迭代后，计算它的距离向量表（如我们之前对图 4-30 讨论时做的那样）

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p31.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p31.1.png)

#### P32 考虑在距离向量路由选择中的无穷计数问题。如果我们减小一条链路的费用，将会出现无穷计数问题吗？为什么？如果我们连接没有链路的两个结点，会出现什么情况？

  * 减小链路的费用不会出现无穷计数问题，因为减小链路的费用不会出现环，而增加链路费用会导致出现环。
  * 连接两个没有链路的结点，相当于把链路费用从无穷大减小到有限。

#### P33 讨论在图 4-30 中的距离向量算法，距离向量 D(x) 中的每个值不是递增的并且最终将在有限步中稳定下来。

  * Bellman-Ford 方程只会减小每个结点的距离向量，而没有增加操作，如果没有改变发生，那么就不会发送任何报文，因为链路费用是有限的，因此距离向量将会经过有限步骤最终达到稳定。

#### P34 考虑图 4-31。假定有另一台路由器 w, 与路由器 y 和 z 连接。所有链路的费用给定如下：c(x, y) = 4, c(x, z) = 50, c(y, w) = 1, c(z, w) = 1, c(y, z) = 3。假设在距离向量路由选择算法中使用了毒性逆转。
#### a. 当距离向量路由选择稳定时，路由器 w, y 和 z 向 x 通知它们的距离。它们告诉彼此什么样的距离值？
#### b. 现在假设 x 和 y 之间的链路成本增加到 60。即使使用了毒性逆转，将会存在无穷计数的问题吗？为什么？如果存在无穷计数的问题，距离向量路由选择需要迭代多少次才能再次达到稳定状态？评估你的答案。
#### c. 如果 c(y, x) 从 4 变化到 60，怎样修改 c(y, z) 使得不存在无穷计数问题。

  * a.
    * 当距离向量路由选择稳定时，各结点距离向量如下图所示
    * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p34.png)
    * 当距离向量路由选择稳定时，路径的毒化如下所述
	    * 对于 x 结点
	      * 到达 y 下一跳是 y，因此通告 y `Dx(y) = ∞`
	      * 到达 w 下一跳是 y，因此通告 y `Dx(w) = ∞`
	      * 到达 z 下一跳是 y，因此通告 y `Dx(z) = ∞`
	    * 对于 y 结点
	      * 到达 x 下一跳是 x，因此通告 x `Dy(x) = ∞`
	      * 到达 w 下一跳是 w，因此通告 w `Dy(w) = ∞`
	      * 到达 z 下一跳是 w，因此通告 z `Dy(z) = ∞`
	    * 对于 w 结点
	      * 到达 x 下一跳是 y，因此通告 y `Dw(x) = ∞`
	      * 到达 y 下一跳是 y，因此通告 y `Dw(y) = ∞`
	      * 到达 z 下一跳是 z，因此通告 z `Dw(z) = ∞`
	    * 对于 z 结点
	      * 到达 x 下一跳是 w，因此通告 w `Dz(x) = ∞`
	      * 到达 y 下一跳是 w，因此通告 w `Dz(y) = ∞`
	      * 到达 w 下一跳是 w，因此通告 w `Dz(w) = ∞`
	   * 下面是上述毒化的图示
    	* ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p34.1.png)
    * 对于 z 来说
	    * 从上图中可以看出，w 是 z 到 x 路径上的下一跳，因此 z 将向 w 通告，Dz(x) = ∞, 这样的话，假设 c(y, w) 增加，那么由于 w 知道（其实它被欺骗了）它无法通过 z 到达 x，因此它不会试图把分组传递给 z，也就不会形成环。
	    * 但是，y 不是 z 到 x 路径上的下一跳，z 其实不关心 w 如何将分组传递给 x，所以 z 将继续向 y 通告，Dz(x) = 6
    * 对于 w 来说
    	* y 是 w 去往 x 的下一跳，因此 w 将向 y 通告，Dw(x) = ∞，这样的话，假设 c(y, x) 增加，那么由于 y 知道 (其实它被欺骗了)它不能通过 w 到达 x，因此它不会试图将分组传递给 w，也就避免了形成环。
    	* 由于 z 不是 w 去往 x 的下一跳，因此 w 向 z 通告，可以经由它以 Dw(x) = 5 到达 x
    * 对于 y 来说
       * y 的下一跳就是 x，因此 y 将通告 z 和 w, 它可以以 Dy(x) = 4 到达 x

 * b.
   * 假设 c(x, y) = 60，那么现在算法运行轨迹如下：
   * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p34.2.png)
   
   * 从图中可以发现，即使使用了毒性逆转，仍然出现了无穷计数的问题。从 t1 时刻 c(x, y) 增加到 60 开始，分析如下
   
	   * **t1** y 知道通过 z 能够以 3 + 6 = 9 到达 x，因此从 y 去往 x 的路上，下一跳是 z，并毒化 `z -> y`，同时将通告邻居 w 和 z
	   
	   * **t2** w 收到 y 的通告，知道通过 y 能够以 9 + 1 = 10 到达 x，因此从 w 去往 x 的路上，下一跳是 y，并毒化 `y -> w`，同时通告邻居 y 和 z
	   
	   * **t3** z 收到 w 的通告，知道通过 w 能够以 10 + 1 = 11 到达 x，因此从 z 去往 x 的路上，下一跳是 w，并毒化 `w -> z`，同时通告邻居 y 和 w
	   
	   * **t4** y 收到 z 的通告，知道通过 z 能够以 3 + 11 = 14 到达 x，因此 y 去往 x 的路上，下一跳是 z，并毒化 `z -> y`，同时通告邻居 w 和 z
	   
	   * **t5** w 收到 y 的通告，知道通过 y 能够以 14 + 1 = 15 到达 x，毒化来路，通告邻居
	   
	   * **t6** z 收到 w 的通告，知道通过 w 能够以 15 + 1 = 16 到达 x，毒化来路，通告邻居
	   
	   * **t7** y 知道能够以 3 + 16 = 19 到达 x，毒化来路，通告邻居
	   
	   * **t8** w 知道能够以 20 到达 x，毒化来路，通告邻居
	   
	   * **t9** z 知道 21 到达 x
	
	   * **t10** y 知道 24 到达 x
	   * **t11** w 知道 25 到达 x
	   * **t12** z 知道 26 到达 x
	   * **t13** y 知道 29 到达 x
	   * **t14** w 知道 30
	   * **t15** z 知道 31
	   * **t16** y 知道 34
	   * **t17** w 知道 35
	   * **t18** z 36
	   * **t19** y 39
	   * **t20** w 40
	   * **t21** z 41
	   * **t22** y 44
	   * **t23** w 45
	   
	   * **t24** z 收到 w 的通告，知道通过 w 能够以 45 + 1 = 46 到达 x，因此从 z 去往 x 的路上，下一跳是 w，并毒化 `w -> z`，同时通告邻居 y 和 w
	   
	   * **t25** y 收到 z 的通告，知道通过 z 能够以 46 + 3 = 49 到达 x，因此从 y 去往 x 的路上，下一跳是 z，并毒化 `z -> y`，同时通告邻居 z 和 w
	   
	   * **t26** w 收到 y 的通告，知道通过 y 能够以 49 + 1 = 50 到达 x，因此从 w 去往 x 的路上，下一跳是 y，并毒化 `y -> w`，同时通告邻居 y 和 z
	   
	   * **t27** ⚠️⚠️⚠️z 收到 w 的通告，知道通过 w 能够以 50 + 1 到达 x，但 z 也知道，通过 50 能够直接到达 x，因此从 z 去往 x 的路上，下一跳是 x，并毒化 `x -> z`。同时通告邻居 y 和 w : 通过 z 能够以 50 到达 x。
	   
	   * **t28** 🍎y 收到 z 的通告，那么 y 知道通过 z 能够以 50 + 3 = 53 到达 x，由于在 **t26** 中 `y -> w` 已经被毒化，因此由 y 去往 x 的路上，y 不会选择使用 w 作为下一跳，因此下一跳是 z，并毒化 `z -> y`，同时通告邻居 x 和 w；🍎w 收到 z 的通告，w 知道通过 y 能够以 1 + 49 = 50 到达 x，也知道通过 z 能够以 50 + 1 = 51 到达 x，因此选择 y 作为下一跳，并毒化 `y -> w`，同时通告邻居 y 和 z
	   
	   * **t29** 🍎w 收到 y 的通告，w 知道 y 能够以 53 + 1 = 54 到达 x，也知道通过 z 能够以 50 + 1 = 51 到达 x，因此选择 z 作为下一跳，并毒化 `z -> w`，同时通告邻居 y 和 z；🍎z 收到 w 的通告，z 不发生改变
	   
	   * **t30** 🍎y 收到 w 的通告， y 变为 1 + 51 = 52，下一跳是 w，然后通告 w 和 z；🍎 z 收到 w 的通告，z 不发生改变
	   
	   * **t31** w 不发生改变，z 不发生改变
  * 所以总共需要迭代 31 次才能达到稳定状态。

  * c.
    * 当 c(y, x) 从 4 变化为 60 时，切断 x - y 就可以接触无穷计数问题。

#### P35 描述在 BGP 中是如何检测路径中的环路的。

  * 如下图所示
    * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/BGP_check_loop.png)

#### P36 一台 BGP 路由器将总是选择具有最短 AS 路径长度的无环路由吗？评估你的答案

   * 被选择的路径并不总是必须是具有最短 AS 间路径的，许多因素都需要被考虑进去，很有可能 AS 会出于经济原因从而选择一条 AS 间路径更长的而不是更短的路径，比如一个 AS 可能将流量转发给离它更远的邻居，而不是离他更近的那个。

#### P37 考虑下图所示的网络。假定 AS3 和 AS2 正在运行 OSPF 作为其 AS 内部路由选择协议。假定 AS1 和 AS4 正在运行 RIP 作为其 AS 内部路由选择协议。假定 AS 间路由选择协议使用的是 eBGP 和 iBGP。假定最初在 AS2 和 AS4 之间不存在物理链路。
#### a. 路由器 3c 从下列哪个路由选择协议学习到了前缀 x: OSPF、RIP、eBGP 或 iBGP
#### b. 路由器 3a 从哪个路由器选择协议学习到了前缀 x?
#### c. 路由器 1c 从哪个路由选择协议学习到了前缀 x ?
#### d. 路由器 1d 从哪个路由选择协议学习到了前缀 x ?

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p37.png)

   * a.
     * eBGP
    
   * b.
     * iBGP
    
   * c.
     * eBGP
    
   * d.
     * iBGP

#### P38 参考上一习题，一旦路由器 1d 知道了 x 的情况，它将一个表项（x, I） 放入其转发表中。
#### a. 对这个表项而言，I 将等于 I1 还是 I2? 用一句话解释其原因。
#### b. 现在假定在 AS2 和 AS4 之间有一条物理链路，显示为图中的虚线。假定路由器 1d 知道经 AS2 以及经 AS3 能够访问到 x。I 将设置为 I1 还是 I2？用一句话解释其原因。
#### c. 现在假定有另一个 AS，它成为 AS5，其位于路径 AS2 和 AS4 之间（没有显示在图中）。假定路由器 1d 知道经过 AS2 AS5 AS4 以及经过 AS3 AS4 能够访问到 x。I 将设置 I1 还是 I2？用一句话解释其原因。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p37.png)

  * a.
    * I 将等于 I1，因为 I1 在到 1c 的最低费用路径上。

  * b.
    * 因为 1d 知道经过 AS3 能访问到 AS4，知道经过 AS2 能访问到 AS4，因此 1c 和 1b 两台路由器都在 1d 的考虑范围内，因为 AS-PATH 相同，这时候采用热土豆选择，因为从 1d 到达 1b 的费用更低，因此 I 被设置为 I2
    
  * c.
    * 虽然 AS1 能通过 AS3 到达 AS4，AS1 能通过 AS2 AS5 到达 AS4，但是无疑首先考虑的是 AS-PATH 长度，所以会设置 I 为 I1

#### P39 考虑下面的网络。ISP B 为地区 ISP A 提供国家主干网服务。ISP C 为地区 ISP D 提供国家主干网服务。每个 ISP 由一个 AS 组成。B 和 C 使用 BGP 在两个地方互相对等。考虑从 A 到 D 的流量。B 宁愿将流量交给西海岸的 C （使得 C 将必须承担承载跨越整个国家流量的费用），而 C 宁愿经其东海岸与 B 对等的站点得到这些流量（使得 B 将承载跨越整个国家的流量）。C 可能使用什么样的 BGP 机制，使得 B 将通过东海岸对等点传递 A 到 D 的流量？要回答这个问题，你需要钻研 BGP 的规范。

  * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p39.png)
  
  * 为了让 B 承载跨越整个国家的流量，从而只通过 C 东海岸的路由器得到这些流量。那么 C 将只通过东海岸的网关路由器告诉 B 关于 C 到 D 的路由信息。



