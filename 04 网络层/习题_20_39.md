#### P20 假定在源主机和目的主机 B 之间的数据报被限制为 1500 字节（包括首部）。假设 IP 首部为 20 字节，要发送一个 5 MB组成的 MP3 需要多少个数据报？解释你的答案是如何计算的。

  * 即每个数据报中的数据长度为 1480，那么每个应用层数据的长度为 1460，因此总共有 `5000000 / 1460 = 3425`

#### P21 考虑在图 4-22 中建立的网络。假定 ISP 此时为路由器分配地址 24.34.112.235 以及家庭网络的网络地址是 192.168.1/24。
#### a. 在家庭网络中为所有接口分配地址
#### b. 假定每台主机具有两个进行中的 TCP 连接，所有都是对主机 128.119.40.86 的 80 端口的。在 NAT 转换表中提供 6 个对应表项。

  * a.
    
    |接口|IP地址|
    |:---:|:---:|
    |路由器接口| `192.168.1.1`|
    |第一台主机| `192.168.1.2`|
    |第二台主机| `192.168.1.3`|
    |第三台主机| `192.168.1.4`|
  
  * b.
    
    |NAT 转换表|WAN端|LAN端|
    |:---:|:--:|:---:|
    |A|`24.34.112.235, 1000`| `192.168.1.2, 4000` |
    |A|`24.34.112.235, 1001`| `192.168.1.2, 4001` |
    |B|`24.34.112.235, 1002`| `192.168.1.2, 4002` |
    |B|`24.34.112.235, 1003`| `192.168.1.2, 4003` |
    |C|`24.34.112.235, 1004`| `192.168.1.2, 4004` |
    |C|`24.34.112.235, 1005`| `192.168.1.2, 4005` |

#### P22 假设你有兴趣检测 NAT 后面的主机数量。你观察到在每个 IP 分组上 IP 层顺序地标出一个标示号。由一台主机生成的第一个 IP 分组的标示号是一个随机数，后继 IP 分组的标示号是顺序分配的。假设由 NAT 后面主机产生的所有 IP 分组都发往外部。
#### a. 基于这个观察，假定你能够俘获由 NAT 向外部发送的所有分组，你能概要给出一种简单的技术来检测 NAT 后面不同主机的数量吗？评估你的答案。
#### b. 如果标示号不是顺序分配而是随机分配的，这种技术还能正常工作吗？评估你的答案。

  * a.
    * 意思是每台主机进行 IP 分片时，为 IP 数据报选择的 2 字节标示是一个随机值，第一个报文的所有分片都是该随机值，第二个报文的所有分片是该随机值加 1，由于每台主机都是选一个随机的初始值，但随后的分组都是连续递增的，所以将这些切片划分为连续递增的多个簇，最后统计簇的数量，就是 NAT 后面主机的数量。
   
  * b.
    * 不能，因为无法统计连续递增的标示号的数量了。

#### P23 在这个习题中，我们将探讨 NAT 对 P2P 应用程序的影响。假定具有用户名 Arnold 的对等方通过查询发现，具有用户名 Bernard 的对等方有一个要下载的文件。同时假定 Bernard 和 Arnold 都位于 NAT 后面。尝试设计一种技术，使得 Arnold 与 Bernard 创建一条 TCP 连接，而不对 NAT 做应用特定的配置。如果你难以设计这样的技术，试讨论原因。

  * 如果不对 NAT 做应用特定的配置，那么直接 TCP 连接两个 NAT 后面的主机是无法做到的。因为你不知道每个 NAT 端口映射的规则。如果可以对 NAT 做应用特定的配置的话，那么只需要双方约定一个端口映射，那么就可以完成两个 NAT 后面的主机的 TCP 连接。

#### P24 观察图 4-27，列举从 y 到 u 不包含任何环路的路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p24.png)

  * 第一跳是 x
    * y - x - u
    * y - x - v - u
    * y - x - w - u
    * y - x - v - w - u
  
  * 第一跳是 w
    * y - w - u
    * y - w - v - u
    * y - w - x - u
    * y - w - x - v - u
  
  * 第一跳是 z
    * y - z - w - u
    * y - z - w - v - u
    * y - z - w - x - u
    * y - z - w - x - v - u


#### P25 重复习题 P24，列举从 x 到 z, z 到 u 以及 z 到 w 的不包含任何环路的路径。

  * x 到 z
    * 第一跳是 u
      * x - u - w - z
      * x - u - w - y - z
      * x - u - w - x - y - z
      * x - u - w - v - x - y - z
      * x - u - v - w - z
      * x - u - v - w - y - z
    * 第一跳是 v
      * x - v - u - w - z
      * x - v - u - w - y - z
      * x - v - u - w - x - y - z
      * x - v - w - z
      * x - v - w - y - z
    * 第一跳是 w
      * x - w - z
      * x - w - y - z
    * 第一跳是 y
      * x - y - z
      * x - y - w - z

  * z 到 u
    * 第一跳是 w
      * z - w - u
      * z - w - v - u
      * z - w - v - x - u
      * z - w - y - x - u
      * z - w - y - x - v - u
      * z - w - x - u
      * z - w - x - v - u
    * 第一跳是 y
      * z - y - w - u
      * z - y - w - v - u
      * z - y - w - v - x - u
      * z - y - w - x - u 
      * z - y - w - x - v - u
      * z - y - x - u
      * z - y - x - v - u
      * z - y - x - v - w - u
      * z - y - x - w - u
      * z - y - x - w - v - u

  * z 到 w
    * z - w
    * 第一跳是 y
      * z - y - w
      * z - y - x - w
      * z - y - x - v - w
      * z - y - x - v - u - w
      * z - y - x - u - w
      * z - y - x - u - v - w

#### P26 考虑下面的网络。对于标明的链路费用，用 Dijkstra 的最短路径算法计算出从 x 到所有网络结点的最短路径。通过计算一个类似于表 4-3 的表，说明该算法是如何工作的。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.1.png)

  * [Dijkstra 算法实现](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p26.c) 程序运行验证如下所示 : 
  
     ~~~
     ➜  progs git:(master) ✗ ./run.sh p26.c
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from x to z : [distance = 8] { z x 8 } 
		shortest path from x to y : [distance = 6] { y x 6 } 
		shortest path from x to v : [distance = 3] { v x 3 } 
		shortest path from x to t : [distance = 7] { v x 3 }  { v t 4 } 
		shortest path from x to x : [distance = 0]
		shortest path from x to w : [distance = 6] { x w 6 } 
		shortest path from x to u : [distance = 6] { v x 3 }  { v u 3 } 
     ~~~

#### P27 考虑习题 P26 中所示的网络。使用 Dijkstra 算法和一个类似于表 4-3 的表来说明你做的工作:
#### a. 计算出从 t 到所有网络结点的最短路径。
#### b. 计算出从 u 到所有网络结点的最短路径。
#### c. 计算出从 v 到所有网络结点的最短路径。
#### d. 计算出从 w 到所有网络结点的最短路径。
#### e. 计算出从 y 到所有网络结点的最短路径。
#### f. 计算出从 z 到所有网络结点的最短路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

* [Dijkstra 算法实现](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p26.c) 程序运行结果如下所示 : 

   * a.
 
     ~~~C
 ➜  progs git:(master) ✗ ./p26.c.exe t
	[22:37:15:13556] src = t 3
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from t to z : [distance = 15] { v t 4 }  { v x 3 }  { z x 8 } 
	shortest path from t to y : [distance = 7] { y t 7 } 
	shortest path from t to v : [distance = 4] { v t 4 } 
	shortest path from t to t : [distance = 0]
	shortest path from t to x : [distance = 7] { v t 4 }  { v x 3 } 
	shortest path from t to w : [distance = 5] { u t 2 }  { u w 3 } 
	shortest path from t to u : [distance = 2] { u t 2 } 
     ~~~
     
   * b.
   
  ~~~C
➜  progs git:(master) ✗ ./p26.c.exe u
	[22:38:43:827442] src = u 6
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from u to z : [distance = 14] { v u 3 }  { v x 3 }  { z x 8 } 
	shortest path from u to y : [distance = 9] { u t 2 }  { y t 7 } 
	shortest path from u to v : [distance = 3] { v u 3 } 
	shortest path from u to t : [distance = 2] { u t 2 } 
	shortest path from u to x : [distance = 6] { v u 3 }  { v x 3 } 
	shortest path from u to w : [distance = 3] { u w 3 } 
	shortest path from u to u : [distance = 0]
  ~~~
      
   * c.

   ~~~C
   ➜  progs git:(master) ✗ ./p26.c.exe v
	[22:40:27:606071] src = v 2
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from v to z : [distance = 11] { v x 3 }  { z x 8 } 
	shortest path from v to y : [distance = 8] { y v 8 } 
	shortest path from v to v : [distance = 0]
	shortest path from v to t : [distance = 4] { v t 4 } 
	shortest path from v to x : [distance = 3] { v x 3 } 
	shortest path from v to w : [distance = 4] { v w 4 } 
	shortest path from v to u : [distance = 3] { v u 3 }
   ~~~
   
   * d.

   ~~~C
   ➜  progs git:(master) ✗ ./p26.c.exe w
	[22:41:22:309333] src = w 5
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from w to z : [distance = 14] { x w 6 }  { z x 8 } 
	shortest path from w to y : [distance = 12] { v w 4 }  { y v 8 } 
	shortest path from w to v : [distance = 4] { v w 4 } 
	shortest path from w to t : [distance = 5] { u w 3 }  { u t 2 } 
	shortest path from w to x : [distance = 6] { x w 6 } 
	shortest path from w to w : [distance = 0]
	shortest path from w to u : [distance = 3] { u w 3 } 
   ~~~
   
   * e.
   
   ~~~C
   ➜  progs git:(master) ✗ ./p26.c.exe y
	[22:42:1:378307] src = y 1
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from y to z : [distance = 12] { z y 12 } 
	shortest path from y to y : [distance = 0]
	shortest path from y to v : [distance = 8] { y v 8 } 
	shortest path from y to t : [distance = 7] { y t 7 } 
	shortest path from y to x : [distance = 6] { y x 6 } 
	shortest path from y to w : [distance = 12] { y x 6 }  { x w 6 } 
	shortest path from y to u : [distance = 9] { y t 7 }  { u t 2 } 
   ~~~
   
   * f.

   ~~~C
   ➜  progs git:(master) ✗ ./p26.c.exe z
	[22:42:44:217028] src = z 0
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from z to z : [distance = 0]
	shortest path from z to y : [distance = 12] { z y 12 } 
	shortest path from z to v : [distance = 11] { z x 8 }  { v x 3 } 
	shortest path from z to t : [distance = 15] { z x 8 }  { v x 3 }  { v t 4 } 
	shortest path from z to x : [distance = 8] { z x 8 } 
	shortest path from z to w : [distance = 14] { z x 8 }  { x w 6 } 
	shortest path from z to u : [distance = 14] { z x 8 }  { v x 3 }  { v u 3 }
   ~~~
     
#### P28 考虑下图所示的网络，假设每个结点初始时知道到它每个邻居的费用。考虑距离向量算法，并显示在结点 z 中的距离表表项。

#### P29 考虑一个一般性拓扑（即不是以上所显示的特定网络）和一个同步版本的距离向量算法。假设每次迭代时，一个结点与其邻居交换其距离向量并接受它们的距离向量。假定算法开始时，每个结点只知道其直接邻居的费用，在该分布式算法收敛前所需的最大迭代次数是多少？评估你的答案。

#### P30 考虑下图所示的网络段。x 只有两个相连邻居 w 与 y。w 有一条通向目的地 u (没有显示)的最低费用路径，其值为 5；y 有一条通向目的地 u 的最低费用路径，其值为 6。从 w 与 y 到 u (以及 w 与 y 之间)的完整路径没有显示出来。网络中所有链路费用皆为正整数。
#### a. 给出 x 对目的地 w, y 和 u 的距离向量
#### b. 给出对 c(x, w) 或 c(x, y) 的链路费用的变化，使得执行了距离向量算法后，x 将通知其邻居有一条通向 u 的新最低费用路径。
#### c. 给出对 c(x, w) 或 c(x, y) 的链路费用的变化，使得执行了距离向量算法后，x 将不通知其邻居有一条通向 u 的新最低费用路径。







