#### P20 假定在源主机和目的主机 B 之间的数据报被限制为 1500 字节（包括首部）。假设 IP 首部为 20 字节，要发送一个 5 MB组成的 MP3 需要多少个数据报？解释你的答案是如何计算的。

  * 即每个数据报中的数据长度为 1480，那么每个应用层数据的长度为 1460，因此总共有 `5000000 / 1460 = 3425`

#### P21 考虑在图 4-22 中建立的网络。假定 ISP 此时为路由器分配地址 24.34.112.235 以及家庭网络的网络地址是 192.168.1/24。
#### a. 在家庭网络中为所有接口分配地址
#### b. 假定每台主机具有两个进行中的 TCP 连接，所有都是对主机 128.119.40.86 的 80 端口的。在 NAT 转换表中提供 6 个对应表项。

  * a.
    
    |接口|IP地址|
    |:---:|:---:|
    |路由器接口| `192.168.1.1`|
    |第一台主机| `192.168.1.2`|
    |第二台主机| `192.168.1.3`|
    |第三台主机| `192.168.1.4`|
  
  * b.
    
    |NAT 转换表|WAN端|LAN端|
    |:---:|:--:|:---:|
    |A|`24.34.112.235, 1000`| `192.168.1.2, 4000` |
    |A|`24.34.112.235, 1001`| `192.168.1.2, 4001` |
    |B|`24.34.112.235, 1002`| `192.168.1.2, 4002` |
    |B|`24.34.112.235, 1003`| `192.168.1.2, 4003` |
    |C|`24.34.112.235, 1004`| `192.168.1.2, 4004` |
    |C|`24.34.112.235, 1005`| `192.168.1.2, 4005` |

#### P22 假设你有兴趣检测 NAT 后面的主机数量。你观察到在每个 IP 分组上 IP 层顺序地标出一个标示号。由一台主机生成的第一个 IP 分组的标示号是一个随机数，后继 IP 分组的标示号是顺序分配的。假设由 NAT 后面主机产生的所有 IP 分组都发往外部。
#### a. 基于这个观察，假定你能够俘获由 NAT 向外部发送的所有分组，你能概要给出一种简单的技术来检测 NAT 后面不同主机的数量吗？评估你的答案。
#### b. 如果标示号不是顺序分配而是随机分配的，这种技术还能正常工作吗？评估你的答案。

  * a.
    * 意思是每台主机进行 IP 分片时，为 IP 数据报选择的 2 字节标示是一个随机值，第一个报文的所有分片都是该随机值，第二个报文的所有分片是该随机值加 1，由于每台主机都是选一个随机的初始值，但随后的分组都是连续递增的，所以将这些切片划分为连续递增的多个簇，最后统计簇的数量，就是 NAT 后面主机的数量。
   
  * b.
    * 不能，因为无法统计连续递增的标示号的数量了。

#### P23 在这个习题中，我们将探讨 NAT 对 P2P 应用程序的影响。假定具有用户名 Arnold 的对等方通过查询发现，具有用户名 Bernard 的对等方有一个要下载的文件。同时假定 Bernard 和 Arnold 都位于 NAT 后面。尝试设计一种技术，使得 Arnold 与 Bernard 创建一条 TCP 连接，而不对 NAT 做应用特定的配置。如果你难以设计这样的技术，试讨论原因。

  * 如果不对 NAT 做应用特定的配置，那么直接 TCP 连接两个 NAT 后面的主机是无法做到的。因为你不知道每个 NAT 端口映射的规则。如果可以对 NAT 做应用特定的配置的话，那么只需要双方约定一个端口映射，那么就可以完成两个 NAT 后面的主机的 TCP 连接。

#### P24 观察图 4-27，列举从 y 到 u 不包含任何环路的路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p24.png)

  * 第一跳是 x
    * y - x - u
    * y - x - v - u
    * y - x - w - u
    * y - x - v - w - u
  
  * 第一跳是 w
    * y - w - u
    * y - w - v - u
    * y - w - x - u
    * y - w - x - v - u
  
  * 第一跳是 z
    * y - z - w - u
    * y - z - w - v - u
    * y - z - w - x - u
    * y - z - w - x - v - u


#### P25 重复习题 P24，列举从 x 到 z, z 到 u 以及 z 到 w 的不包含任何环路的路径。

  * x 到 z
    * 第一跳是 u
      * x - u - w - z
      * x - u - w - y - z
      * x - u - w - x - y - z
      * x - u - w - v - x - y - z
      * x - u - v - w - z
      * x - u - v - w - y - z
    * 第一跳是 v
      * x - v - u - w - z
      * x - v - u - w - y - z
      * x - v - u - w - x - y - z
      * x - v - w - z
      * x - v - w - y - z
    * 第一跳是 w
      * x - w - z
      * x - w - y - z
    * 第一跳是 y
      * x - y - z
      * x - y - w - z

  * z 到 u
    * 第一跳是 w
      * z - w - u
      * z - w - v - u
      * z - w - v - x - u
      * z - w - y - x - u
      * z - w - y - x - v - u
      * z - w - x - u
      * z - w - x - v - u
    * 第一跳是 y
      * z - y - w - u
      * z - y - w - v - u
      * z - y - w - v - x - u
      * z - y - w - x - u 
      * z - y - w - x - v - u
      * z - y - x - u
      * z - y - x - v - u
      * z - y - x - v - w - u
      * z - y - x - w - u
      * z - y - x - w - v - u

  * z 到 w
    * z - w
    * 第一跳是 y
      * z - y - w
      * z - y - x - w
      * z - y - x - v - w
      * z - y - x - v - u - w
      * z - y - x - u - w
      * z - y - x - u - v - w

#### P26 考虑下面的网络。对于标明的链路费用，用 Dijkstra 的最短路径算法计算出从 x 到所有网络结点的最短路径。通过计算一个类似于表 4-3 的表，说明该算法是如何工作的。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.1.png)

  * [Dijkstra 算法实现](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p26.c) 程序运行验证如下所示 : 
  
     ~~~
     ➜  progs git:(master) ✗ ./run.sh p26.c
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from x to z : [distance = 8] { z x 8 } 
		shortest path from x to y : [distance = 6] { y x 6 } 
		shortest path from x to v : [distance = 3] { v x 3 } 
		shortest path from x to t : [distance = 7] { v x 3 }  { v t 4 } 
		shortest path from x to x : [distance = 0]
		shortest path from x to w : [distance = 6] { x w 6 } 
		shortest path from x to u : [distance = 6] { v x 3 }  { v u 3 } 
     ~~~

#### P27 考虑习题 P26 中所示的网络。使用 Dijkstra 算法和一个类似于表 4-3 的表来说明你做的工作:
#### a. 计算出从 t 到所有网络结点的最短路径。
#### b. 计算出从 u 到所有网络结点的最短路径。
#### c. 计算出从 v 到所有网络结点的最短路径。
#### d. 计算出从 w 到所有网络结点的最短路径。
#### e. 计算出从 y 到所有网络结点的最短路径。
#### f. 计算出从 z 到所有网络结点的最短路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

* [Dijkstra 算法实现](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p26.c) 程序运行结果如下所示 : 

   * a.
 
     ~~~C
	 ➜  progs git:(master) ✗ ./p26.c.exe t
		[22:37:15:13556] src = t 3
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from t to z : [distance = 15] { v t 4 }  { v x 3 }  { z x 8 } 
		shortest path from t to y : [distance = 7] { y t 7 } 
		shortest path from t to v : [distance = 4] { v t 4 } 
		shortest path from t to t : [distance = 0]
		shortest path from t to x : [distance = 7] { v t 4 }  { v x 3 } 
		shortest path from t to w : [distance = 5] { u t 2 }  { u w 3 } 
		shortest path from t to u : [distance = 2] { u t 2 } 
     ~~~
     
   * b.
   
      ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe u
		[22:38:43:827442] src = u 6
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from u to z : [distance = 14] { v u 3 }  { v x 3 }  { z x 8 } 
		shortest path from u to y : [distance = 9] { u t 2 }  { y t 7 } 
		shortest path from u to v : [distance = 3] { v u 3 } 
		shortest path from u to t : [distance = 2] { u t 2 } 
		shortest path from u to x : [distance = 6] { v u 3 }  { v x 3 } 
		shortest path from u to w : [distance = 3] { u w 3 } 
		shortest path from u to u : [distance = 0]
      ~~~
      
   * c.

	   ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe v
		[22:40:27:606071] src = v 2
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from v to z : [distance = 11] { v x 3 }  { z x 8 } 
		shortest path from v to y : [distance = 8] { y v 8 } 
		shortest path from v to v : [distance = 0]
		shortest path from v to t : [distance = 4] { v t 4 } 
		shortest path from v to x : [distance = 3] { v x 3 } 
		shortest path from v to w : [distance = 4] { v w 4 } 
		shortest path from v to u : [distance = 3] { v u 3 }
	   ~~~
   
   * d.

	   ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe w
		[22:41:22:309333] src = w 5
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from w to z : [distance = 14] { x w 6 }  { z x 8 } 
		shortest path from w to y : [distance = 12] { v w 4 }  { y v 8 } 
		shortest path from w to v : [distance = 4] { v w 4 } 
		shortest path from w to t : [distance = 5] { u w 3 }  { u t 2 } 
		shortest path from w to x : [distance = 6] { x w 6 } 
		shortest path from w to w : [distance = 0]
		shortest path from w to u : [distance = 3] { u w 3 } 
	   ~~~
   
   * e.
   
	   ~~~
	   ➜  progs git:(master) ✗ ./p26.c.exe y
		[22:42:1:378307] src = y 1
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from y to z : [distance = 12] { z y 12 } 
		shortest path from y to y : [distance = 0]
		shortest path from y to v : [distance = 8] { y v 8 } 
		shortest path from y to t : [distance = 7] { y t 7 } 
		shortest path from y to x : [distance = 6] { y x 6 } 
		shortest path from y to w : [distance = 12] { y x 6 }  { x w 6 } 
		shortest path from y to u : [distance = 9] { y t 7 }  { u t 2 } 
	   ~~~
   
   * f.

	   ~~~C
	   ➜  progs git:(master) ✗ ./p26.c.exe z
		[22:42:44:217028] src = z 0
		**************** print structure of graph ***************
		V = 7
		E = 12
		0 : { z x 8 } { z y 12 }
		1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
		2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
		3 : { u t 2 } { v t 4 } { y t 7 }
		4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
		5 : { u w 3 } { x w 6 } { v w 4 }
		6 : { u t 2 } { u w 3 } { v u 3 }
		*********************************************************
		shortest path from z to z : [distance = 0]
		shortest path from z to y : [distance = 12] { z y 12 } 
		shortest path from z to v : [distance = 11] { z x 8 }  { v x 3 } 
		shortest path from z to t : [distance = 15] { z x 8 }  { v x 3 }  { v t 4 } 
		shortest path from z to x : [distance = 8] { z x 8 } 
		shortest path from z to w : [distance = 14] { z x 8 }  { x w 6 } 
		shortest path from z to u : [distance = 14] { z x 8 }  { v x 3 }  { v u 3 }
	   ~~~
     
#### P28 考虑下图所示的网络，假设每个结点初始时知道到它每个邻居的费用。考虑距离向量算法，并显示在结点 z 中的距离表表项。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p28.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p28.1.png)

#### P29 考虑一个一般性拓扑（即不是以上所显示的特定网络）和一个同步版本的距离向量算法。假设每次迭代时，一个结点与其邻居交换其距离向量并接受它们的距离向量。假定算法开始时，每个结点只知道其直接邻居的费用，在该分布式算法收敛前所需的最大迭代次数是多少？评估你的答案。

  * 对于一个同步版本的距离向量算法有 4 个结点 A - B - C - D，在第一次交换彼此的距离向量后，A 知道了到 C 两跳的最短路径，这是 B 告诉它的。C 知道了到达 A 两跳的最短路径，这是 B 告诉它的，B 知道了到达 D 两跳的最短路径，这是 C 告诉它的。但是 A 不知道如何到 D，D 也是如此。在下一次交换距离向量后，所有结点都知道了如何到达彼此的信息。因为 B 知道如何到 D，B 告诉了 A，因此 A 知道了如何到 D。因此，假设 A 是 B 的邻居，在 B 向它的所有邻居交换了一次距离向量后，所有 B 的邻居都知道了到 A 的一跳或者两跳的最短路径。因此假设图的 "直径" 为 d，那么在迭代 d - 1 次后，所有结点都知道如何抵达彼此，那么算法将开始收敛。 

#### P30 考虑下图所示的网络段。x 只有两个相连邻居 w 与 y。w 有一条通向目的地 u (没有显示)的最低费用路径，其值为 5；y 有一条通向目的地 u 的最低费用路径，其值为 6。从 w 与 y 到 u (以及 w 与 y 之间)的完整路径没有显示出来。网络中所有链路费用皆为正整数。
#### a. 给出 x 对目的地 w, y 和 u 的距离向量
#### b. 给出对 c(x, w) 或 c(x, y) 的链路费用的变化，使得执行了距离向量算法后，x 将通知其邻居有一条通向 u 的新最低费用路径。
#### c. 给出对 c(x, w) 或 c(x, y) 的链路费用的变化，使得执行了距离向量算法后，x 将不通知其邻居有一条通向 u 的新最低费用路径。

#### P31 考虑如图 4-30 中所示的 3 个结点的拓扑。不使用显示在图 4-30 中的费用值，链路费用值现在是 c(x, y) = 3, c(y, z) = 6, c(z, x) = 4。在距离向量表初始化后和在同步版本的距离向量算法每次迭代后，计算它的距离向量表（如我们之前对图 4-30 讨论时做的那样）

#### P32 考虑在距离向量路由选择中的无穷计数问题。如果我们减小一条链路的费用，将会出现无穷计数问题吗？为什么？如果我们连接没有链路的两个结点，会出现什么情况？

#### P33 讨论在图 4-30 中的距离向量算法，距离向量 D(x) 中的每个值不是递增的并且最终将在有限步中稳定下来。

#### P34 考虑图 4-31。假定有另一台路由器 w, 与路由器 y 和 z 连接。所有链路的费用给定如下：c(x, y) = 4, c(x, z) = 50, c(y, w) = 1, c(z, w) = 1, c(y, z) = 3。假设在距离向量路由选择算法中使用了毒性逆转。
#### a. 当距离向量路由选择稳定时，路由器 w, y 和 z 向 x 通知它们的距离。它们告诉彼此什么样的距离值？
#### b. 现在假设 x 和 y 之间的链路成本增加到 60。即使使用了毒性逆转，将会存在无穷计数的问题吗？为什么？如果存在无穷计数的问题，距离向量路由选择需要迭代多少次才能再次达到稳定状态？评估你的答案。


#### P35 描述在 BGP 中是如何检测路径中的环路的。

#### P36 一台 BGP 路由器将总是选择具有最短 AS 路径长度的无环路由吗？评估你的答案

#### P37 考虑下图所示的网络。假定 AS3 和 AS2 正在运行 OSPF 作为其 AS 内部路由选择协议。假定 AS1 和 AS4 正在运行 RIP 作为其 AS 内部路由选择协议。假定 AS 间路由选择协议使用的是 eBGP 和 iBGP。假定最初在 AS2 和 AS4 之间不存在物理链路。
#### a. 路由器 3c 从下列哪个路由选择协议学习到了前缀 x: OSPF、RIP、eBGP 或 iBGP
#### b. 路由器 3a 从哪个路由器选择协议学习到了前缀 x?
#### c. 路由器 1c 从哪个路由选择协议学习到了前缀 x ?
#### d. 路由器 1d 从哪个路由选择协议学习到了前缀 x ?

#### P38 参考上一习题，一旦路由器 1d 知道了 x 的情况，它将一个表项（x, I） 放入其转发表中。
#### a. 对这个表项而言，I 将等于 I1 还是 I2? 用一句话解释其原因。
#### b. 现在假定在 AS2 和 AS4 之间有一条物理链路，显示为图中的虚线。假定路由器 1d 知道经 AS2 以及经 AS3 能够访问到 x。I 将设置为 I1 还是 I2？用一句话解释其原因。
#### c. 现在假定有另一个 AS，它成为 AS5，其位于路径 AS2 和 AS4 之间（没有显示在图中）。假定路由器 1d 知道经过 AS2 AS5 AS4 以及经过 AS3 AS4 能够访问到 x。I 将设置 I1 还是 I2？用一句话解释其原因。

#### P39 考虑下面的网络。ISP B 为地区 ISP A 提供国家主干网服务。ISP C 为地区 ISP D 提供国家主干网服务。每个 ISP 由一个 AS 组成。B 和 C 使用 BGP 在两个地方互相对等。考虑从 A 到 D 的流量。B 宁愿将流量交给西海岸的 C （使得 C 将必须承担承载跨越整个国家流量的费用），而 C 宁愿经其东海岸与 B 对等的站点得到这些流量（使得 B 将承载跨越整个国家的流量）。C 可能使用什么样的 BGP 机制，使得 B 将通过东海岸对等点传递 A 到 D 的流量？要回答这个问题，你需要钻研 BGP 的规范。

#### P40 在图 4-42 中，考虑到达桩网 W、X 和 Y 的路径信息。基于 W 与 X 处的可用信息，它们分别看到的网络拓扑是什么？评估你的答案。Y 所见的拓扑视图如下所示。







