#### P40 在图 4-42 中，考虑到达桩网 W、X 和 Y 的路径信息。基于 W 与 X 处的可用信息，它们分别看到的网络拓扑是什么？评估你的答案。Y 所见的拓扑视图如下所示。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/BGP_routing_strategy.png)

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p40.1.png)

  * 从上图可以看出，Y 知道经由 C 可达 X，知道经由 C 可达 A，经过 A 可达 W，这说明 C 向 Y 通告了 CX，CAW，但是 Y 不知道关于 B 的任何可达信息。说明 B 向 A C 都通告了关于自己不可达 W 或 X 的信息 (或者没有通告关于从 B 可达 W 或 X的任何信息)。
  
![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p40.2.png)

  * 从上图可以看出，W 知道 ABX，也知道 ACY，但是不知道 B 和 C 的互相可达性，因为 B 不会和 C 分享自己的可达信息，所以不会有流量经过 BC 这条路径。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p40.3.png)
 
  * 从上图可以看出，因为 B 和 C 不会分享彼此的可达信息，所以 X 只知道 BAW 可以到达 W，因为在 Y 视角中，能够从 C 到达 X，因此 X 也能知道从 C 可达 Y

#### P41  考虑图 4-42。B 将不会基于 BGP 路由选择经过 X 以 Y 为目的地转发流量。但是某些极为流行的应用程序，其数据分组先朝向 X，然后再朝向 Y。指出一种这样的应用，描述数据分组是如何沿着这条不由 BGP 路由选择给定的路径流动的。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/BGP_routing_strategy.png)

  * 比如 Bittorrent 的对等方 1,2,3 分别位于桩网络 W, X, Y，那么首先位于 X 的对等方从 W 处获取块，之后位于 Y 处的对等方又从 X 处获取了块，这样数据分组相当于就是向朝向 X，再朝向 Y。

#### P42 在图 4-42 中，假定有另一个桩网络 V，它为 ISP A 的客户。假设 B 和 C 具有对等关系，并且 A 是 B 和 C 的客户。假设 A 希望让发向 W 的流量仅来自 B，并且发向 V 的流量来自 B 或 C。A 如何向 B 和 C 通告其路由？C 收到什么样的 AS 路由？

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/BGP_routing_strategy.png)

  * A 将向 B 通告 AS-PATH 为 A-W 和 A-V 的路由
  * A 将向 C 通告 AS-PATH 为 A-V 的路由
  * C 收到的是 B-A-W,  B-A-V, A-V

#### P43 假定 AS X 和 AS Z 不直接连接，但与 AS Y 连接。进一步假定 X 与 Y 具有对等协定，Y 与 Z 具有对等协定。最后，假定 Z 要传送所有 Y 的流量但不想传送 X 的流量。BGP 允许 Z 实现这种策略吗？

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p43.png)
  
  * 因为 Z 要传送 Y 的流量，因此 Z 将会通告 Y 关于 Z 到达其他 AS 的路由，但是因为 X 和 Y 具有对等协定，所以 Y 得知了 Z 的可达性后，就会和 X 分享，因此 X 可以将流量引导至 Y，这样 Z 就不得不传送 X 的流量了。

#### P44 考虑习题 P26 中 7 个结点的网络 (结点标为 t ~ z)。给出根在 z 的包括（作为端主机）结点 u、v、w 和 y 的最低费用树。非形式地讨论一下，为什么你给出的树是一棵最低费用树。

  * 实现 [最小生成树 Prim 算法](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/Algorithms/PrimMST.h)
  * 使用该 Prim 算法来处理下列连通图，得到如下结果:
  
  * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)
  
  ~~~
   **************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	All edges in minimum spaning tree : [weight=25.00] [edgeCount=6]
	{ y x  6.00}
	{ v x  3.00}
	{ u t  2.00}
	{ z x  8.00}
	{ u w  3.00}
	{ v u  3.00}
  ~~~

#### P45 考虑实现广播的两种基本方法：单播模拟与网络层（即路由器协助）广播，并假定使用生成树广播来实现网络层广播。考虑有一个发送方与 32 个接收方。假设发送方通过一棵路由器二叉树与接收方相连。在单播模拟与网络层广播情况下，对于这个拓扑，发送一个广播分组的费用各是多少？这里每经过单一链路发送一个分组（或一个分组的副本），产生一个单位费用。用什么样的拓扑互联发送方、接收方和路由器，将使得单播模拟与真正的网络层广播产生的费用相差尽可能大？你可按照自己的意愿选择多台路由器。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p45.png)

  * 单播模拟费用为 5 * 32 = 160
  * 生成树广播为 2 + 4 + 8 + 16 + 32 = 62
  
  * 当所有接收方都位于一条线上时，单播模拟和生成树广播差距最大。此时生成树广播为 N (N 为链路的数量), 而单播模拟为 `N(N + 1)/2` 

#### P46 考虑图 4-44 中反向路径转发（RPF）算法的运行。使用相同的拓扑，找出从所有结点到源结点 A 的一系列路径（并像在图 4-44 中那样用粗线指出这些路径），使得如果这些路径是最低费用路径，则结点 B 将接受来自使用 RPF 的结点 A、C 和 D 的 A 的广播报文的副本。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p46.png)

#### P47 考虑图 4-44 中所示的拓扑。假定所有链路具有单位费用并且结点 E 是广播源。在给定结点 E 为源的情况下，使用如图 4-44 中所示的箭头，指出使用 RPF 转发分组的链路，以及不转发分组的链路。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p47.png)

#### P48 使用习题 P26 中的图重复习题 P47。假定 z 是广播源，并且链路费用如在习题 P26 中所示。

  * 首先执行 [Dijkstra 算法](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/Algorithms/Dijkstra.h)确认一棵以 z 为起点的最少费用树，结果如下所示:
  
  ~~~
  	➜  progs git:(master) ✗ ./run.sh p48.c
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	shortest path from z to z : [distance = 0]
	shortest path from z to y : [distance = 12] { z y 12 } 
	shortest path from z to v : [distance = 11] { z x 8 }  { v x 3 } 
	shortest path from z to t : [distance = 15] { z x 8 }  { v x 3 }  { v t 4 } 
	shortest path from z to x : [distance = 8] { z x 8 } 
	shortest path from z to w : [distance = 14] { z x 8 }  { x w 6 } 
	shortest path from z to u : [distance = 14] { z x 8 }  { v x 3 }  { v u 3 } 
  ~~~
  
  * 得到如下所示的最低费用树
  	* ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p48.png)
  
  * 然后从 z 为源开始进行广播
    * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p48.1.png)

#### P49 考虑在图 4-46 中所显示的拓扑，并假定每段链路有单位费用。假设结点 C 在基于中心的多播路由选择算法中被选为中心。假定每个相连路由器都使用到结点 C 的最低费用路径向 C 发送加入报文，画出所产生的基于中心的多播路由选择树。产生的树是一棵最低费用树吗？评估你的答案。

  ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p49.png)

  * 通过运行 [Prim 算法](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p49.c) 可以得到下列结果:
  
  ~~~
   ➜  progs git:(master) ✗ ./run.sh p49.c 
	**************** print structure of graph ***************
	V = 7
	E = 9
	0 : { A C 1 } { A B 1 }
	1 : { B D 1 } { B C 1 } { A B 1 }
	2 : { C E 1 } { C F 1 } { B C 1 } { A C 1 }
	3 : { D G 1 } { E D 1 } { B D 1 }
	4 : { E D 1 } { F E 1 } { C E 1 }
	5 : { F E 1 } { C F 1 }
	6 : { D G 1 }
	*********************************************************
	All edges in minimum spaning tree : [weight= 6.00] [edgeCount=6]
	{ A B  1.00}
	{ A C  1.00}
	{ B D  1.00}
	{ C E  1.00}
	{ C F  1.00}
	{ D G  1.00}
  ~~~
  
  * 从上面算法的运行结果我们得到最小生成树如下所示:
    * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p49.1.png)

  * 由多播路由选择算法得到的多播树如下所示:
    * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p49.2.png)

  * 可以看出，拓扑结构和最小生成树的不同。

#### P50 重复习题 P49，使用习题 P26 中的图。假定中心结点是 v。

![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p26.png)

  * 运行 [Prim 算法](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/progs/p50.c) 得到如下所示的结果

	~~~
	➜  progs git:(master) ✗ ./run.sh p50.c 
	**************** print structure of graph ***************
	V = 7
	E = 12
	0 : { z x 8 } { z y 12 }
	1 : { y v 8 } { y t 7 } { y x 6 } { z y 12 }
	2 : { v w 4 } { v u 3 } { v x 3 } { v t 4 } { y v 8 }
	3 : { u t 2 } { v t 4 } { y t 7 }
	4 : { x w 6 } { v x 3 } { y x 6 } { z x 8 }
	5 : { u w 3 } { x w 6 } { v w 4 }
	6 : { u t 2 } { u w 3 } { v u 3 }
	*********************************************************
	All edges in minimum spaning tree : [weight=25.00] [edgeCount=6]
	{ y x  6.00}
	{ v x  3.00}
	{ u t  2.00}
	{ z x  8.00}
	{ u w  3.00}
	{ v u  3.00}
	~~~
	
	* 由 Prim 算法运行得到的最小生成树如下图所示:
	  * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p50.png)

   * 由多播路由选择算法得到的多播树如下所示:
     * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p50.1.png)

#### P51 在 4.5.1 节中我们学习了计算单播路径的 Dijkstra 的链路状态路由选择算法，这些单播路径分别是从源到所有目的地的最小费用路径。这些路径的并集能够被认为形成了一棵最低单播费用路径树（或一棵最短单播路径树，如果所有链路费用是相同的）。通过构造一个反例，标明最低费用路径树并不总是与最小生成树相同。

  * ![](https://github.com/YangXiaoHei/Networking/blob/master/04%20网络层/images/p51.png)

#### P52 考虑所有结点与 3 个其他结点相连的网络。在单一时间步中，一个结点能够从它的邻居接受到所有传输的广播分组，复制分组，并向它的所有邻居发送之（除了发送给定分组的那个结点）。在下个时间步中，相邻结点能够接收、复制和转发这些分组等等。假定使用无控制洪泛以在这样的网络中提供广播。在时间步 t，多少个广播分组的副本将被传输，假定在时间步 1 期间，由源结点向它的 3 个邻居传输单个广播分组。

#### P53 我们在 4.7 节中看到，没有任何网络层协议能用于标示参与一个多播组的主机。在这种情况下，多播应用程序怎样知道参与一个多播组的主机的身份？

#### P54 设计（给出伪代码描述）一个应用级协议，该协议维护参与一个多播组的所有主机的地址。特别要指出你的协议所使用的网络服务（单播或多播），还要指出你的协议发送报文是在带内还是带外（关于多播组参与者之间的应用数据流）并说明理由。

#### P55 多播地址空间的尺寸有多大？假设现在两个不同的多播组随机地选择一个多播地址。它们选择同一个地址的概率有多大？假设现有 1000 个多播组同时正在进行，随机选择它们的多播组地址。它们冲突的概率有多大？






















