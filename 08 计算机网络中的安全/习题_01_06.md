#### P1 使用图 8-3 中的单码代替密码，加密报文 “This is an easy problem”，并解密报文 "rmij'u unmu xyj"。

   * uasi si mj cmiw
   * wasn't that fun

#### P2 Trudy 使用了已知明文攻击，其中她知道了 7 个字母的（密文，明文）转换对，减少了 8.2.1 节的例子中将被检查的大约 10^9 数量级的可能替换的数量。请说明之。 

   * 见下表
   
| | | | | | | | | | ||
|:---:|:---:| :---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|a|b|c|d|e|f|g|h|i|j|...|
|b|c|d|e|f|g|i|o|p|z|...|

  * 第二行总共有多少种排列呢？26! 种。如果 Trudy 知道了 7 个字母，那么相当于有 7 个格是固定已知的 (已知匹配)，那么剩下的 19 个字母总共能形成 19! 种排列，因此 26! - 19! = 10^9 数量级。

#### P3 考虑图 8-4 所示的多码代替密码系统。利用报文 "The quick brown fox jumps over the lazy dogs" 得到的明文编码，选择明文攻击足以破解所有报文吗？为什么?

   * 对于凯撒密码，这个立马就能攻破，对于单码代替密码，也是立马就能攻破，但是对于多码代替密码系统，得到所有字母的不同匹配并不足以攻破所有报文，因为如果字母重复，那么第二，第三个重复字母所使用的匹配是不同的。

#### P4 考虑图 8-5 中显示的密码块。假设每个块密码 Ti 只是反转了 8 个输入比特的次序（例如，使得 11110000 变为 00001111）。进一步假设 64 比特置乱函数不修改任何比特（使得第 m 个比特的输出值等于第 m 个比特的输入值）。
#### a. 对于 n = 3 和初始 64 比特输入等于 10100000 重复了 8 次，输出的值是多少？
#### b. 重复（a）, 但此时将初始 64 比特的最后一个比特从 0 变为 1。
#### c. 重复（a）和 (b)，但此时假定 64 比特的置乱函数反转了 64 比特的次序。

  * a. 
     * ![](https://github.com/YangXiaoHei/Networking/blob/master/08%20计算机网络中的安全/image/p4.1.png)
  
  * b.
     * ![](https://github.com/YangXiaoHei/Networking/blob/master/08%20计算机网络中的安全/image/p4.2.png) 

  * c.
     * ![](https://github.com/YangXiaoHei/Networking/blob/master/08%20计算机网络中的安全/image/p4.3.png)
     * 第一次
         * 输入 7【10100000】+ 10100001
         * Ti 后 : 7【00000101】+ 10000101
         * 64 比特置乱后 : 10100001 + 7【10100000】
     * 第二次
         * 输入 10100001 + 7【10100000】
         * Ti 后 : 10000101 + 7【00000101】
         * 64 比特置乱后 : 7【10100000】 + 10100001
     * 第三次
         * 输入 7【10100000】 + 10100001
         * Ti 后 : 7【00000101】+ 10000101
         * 64 比特置乱后 : 10100001 + 7【10100000】

