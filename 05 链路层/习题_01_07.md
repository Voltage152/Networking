#### P1 假设某分组的信息内容是比特模式 1110 0110 1001 1101，并且使用了偶校验方案。在采用二维奇偶校验方案的情况下，包含该校验比特的字段的值是什么？你的回答应该使用最小长度校验和字段。

||||||
|:--:|:--:|:--:|:--:|:--:|
|1|1|1|0|1|
|0|1|1|0|0|
|1|0|0|1|0|
|1|1|0|1|1|
|1|1|0|0|0|

#### P2 说明（举一个不同于图 5-5 中那个的例子）二维奇偶校验能够纠正和检测单比特差错，说明（举一个例子）某些双比特差错能够被检测但不能纠正。

  * ![](https://github.com/YangXiaoHei/Networking/blob/master/05%20链路层/images/p2.png)

#### P3 假设某分组的信息部分（图 5-3 中的 D）包含 10 字节，它由字符串 "Link Layer" 的 8 比特无符号二进制 ASCII 表示组成。对该数据计算因特网校验和。

~~~
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "checksum.h"
#include "bin_tool.h"

#define SWAP(_x_) (_x_ = ((_x_ << 8) & 0xFF00) | ((_x_ >> 8) & 0xFF))

int main(int argc, char const *argv[])
{
    if (argc != 2) {
        printf("usage : %s <#msg>", argv[0]);
        exit(1);
    }    

    printAsciiString(argv[1]);

    int len = strlen(argv[1]);
    unsigned short cks = checksum((unsigned short *)argv[1], len);
    SWAP(cks);
    printf("checksum of %s is 【%d】\n",argv[1], cks);
    printf("binary string of cks is 【%s】\n", u16ToBinaryString(cks, EN_GROUP_IN_EIGHTS));
    
    return 0;
}
~~~

  * 运行上述程序 [test.c](https://github.com/YangXiaoHei/Networking/blob/master/05%20链路层/progs/test.c) 得到如下结果:
  
  ~~~
  ➜  progs git:(master) ✗ cc test.c bin_tool.c checksum.c -o test && ./test "Link Layer"
   76 L -> 0100 1100
  105 i -> 0110 1001
  110 n -> 0110 1110
  107 k -> 0110 1011
   32   -> 0010 0000
   76 L -> 0100 1100
   97 a -> 0110 0001
  121 y -> 0111 1001
  101 e -> 0110 0101
  114 r -> 0111 0010
	checksum of Link Layer is 【24051】
	binary string of cks is 01011101 11110011
  ~~~
  
  * ⚠️ ![](https://github.com/YangXiaoHei/Networking/blob/master/05%20链路层/images/checksum_wrong_analyze.png)



