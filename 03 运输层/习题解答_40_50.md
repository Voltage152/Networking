### P40 ~ P50

#### P40. 考虑图 3-58。假设 TCP Reno 是一个经历如上所示行为的协议，回答下列问题。在各种情况中，简要地论证你的回答。
#### a. 指出 TCP 慢启动运行时的时间间隔。
#### b. 指出 TCP 拥塞避免运行时的时间间隔。
#### c. 在第 16 个传输轮回之后，报文段的丢失是根据 3 个冗余 ACK 还是根据超时检测出来的？
#### d. 在第 22 个传输轮回之后，报文段的丢失是根据 3 个冗余 ACK 还是根据超时检测出来的？
#### e. 在第 1 个传输轮回里，ssthresh 的初始值被设置为多少？
#### f. 在第 18 个传输轮回里，ssthresh 的值被设置为多少?
#### g. 在第 24 个传输轮回里，ssthresh 的值设置为多少？
#### h. 在哪个传输轮回内发送第 70 个报文段？
#### i. 假定在第 26 个传输轮回后，通过收到 3 个冗余 ACK 检测出有分组丢失，拥塞的窗口长度和 ssthresh 的值应当是多少？
#### j. 假定使用 TCP Tahoe (而不是 TCP Reno)，并假定在第 16 个传输轮回收到 3 个冗余 ACK。在第 19 个传输轮回，ssthresh 和拥塞窗口长度是什么？
#### k. 再次假设使用 TCP Tahoe, 在第 22 个传输轮回有一个超时事件。从第 17 个传输轮回到第 22 个传输轮回（包括这两个传输轮回），一共发送了多少个分组？

![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p40.png)

> a.
> 
> TCP 在慢启动阶段 cwnd 按照指数增长，因此 [0, 6]、[23, 26]
> 
> b.
> 
> TCP 拥塞避免时拥塞窗口线性增长，因此 [6, 16]、[17, 22]
> 
> c.
> ⚠️⚠️⚠️
> 在第 16 个传输轮回之后，丢包是根据冗余 ACK 检测出来的，如果是超时检测出来的，那么拥塞窗口长度会变为 1
> 
> d.
> 
> 在第 22 个传输轮回之后，丢包是根据超时检测出来的，因为拥塞窗口长度下降为 1
> 
> e.
> 
> 在第 1 个传输轮回中，ssthresh 初始值被设置为 32，因为慢启动阶段在拥塞窗口长度达到 32 时开始进入拥塞避免。
> 
> f.
> 
> 在 18 个传输轮回中，ssthresh 的值被设置为拥塞窗口的一半，此时拥塞窗口为 42，因此 ssthresh 被设置为 21。
> 
> g.
> 
> 在第 24 个传输轮回里，ssthresh 的值被设置为拥塞窗口的一半，当时拥塞窗口为 28，因此 ssthresh 被设置为 14。
> 
> h.
> 
> 在第 7 个传输轮回中发送第 70 个报文。
> 
> i.
> 
> 假定在第 26 个传输轮回后，通过收到 3 个冗余 ACK 检测出有分组丢失，拥塞的窗口长度和 ssthresh 的值应当分别为：`ssthresh = 8 / 2 = 4 MSS，cwnd = ssthresh + 3 x MSS = 7 MSS`
> 
> j.
> 
> TCP Tahoe 没有快速重传，因此接收到 3 个冗余 ACK 的做法也是 ssthresh 变为拥塞窗口的一半，即 21，拥塞窗口变为 1 MSS
> 
> k.
> 
> ⚠️⚠️⚠️⚠️ 为什么第 22 轮是 21 个？
> 
> 再次假设使用 TCP Tahoe, 在第 22 个传输轮回有一个超时事件。从第 17 个传输轮回到第 22 个传输轮回 (包括这两个传输轮回), 16 轮回冗余 ACK, 因此 17 轮回 1，18 -> 2，19 -> 4，20 -> 8，21 -> 16，22 -> 21，因此总共是 1 + 2 + 4 + 8 + 16 + 21 = 52 个分组。

#### P41. 参考图 3-56, 该图描述了 TCP 的 AIMD 算法的收敛性。假设 TCP 不采用乘性减，而是采用按某一常量减小窗口。所得的 AIAD 算法将收敛于一种平等共享算法吗？使用类似于图 3-56 中的图来论证你的结论。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p41.png)
> 
> 我们可以看出，如果只采用某一常量减小窗口，那么 AIAD 只会在 A-B 这一段直线上晃悠，没法收敛到平等共享算法。

#### P42. 在 3.5.4 中，我们讨论了在发生超时事件后将超时间隔加倍。为什么除了这种加倍超时间隔机制外，TCP 还需要基于窗口的拥塞控制机制（如在 3.7 节中学习的那种机制呢）呢？

> 如果 TCP 是停等协议，那么发生超时事件后将超时间隔加倍就足够成为拥塞控制机制了，但 TCP 采用的是流水线机制，加倍某个包的重传超时间隔并不能阻止 TCP 把更多的包发到网络中，只要滑动窗口中还有可用的序号，TCP 就会不断的将分组注入流水线中，因此 TCP 仍然需要基于窗口的拥塞控制机制来让 TCP 不会在网络拥塞时继续向流水线中注入大量分组。

#### P43. 主机 A 通过一条 TCP 连接向主机 B 发送一个很大的文件。在这条连接上，不会出现任何分组丢失和定时器超时。主机 A 与因特网连接链路的传输速率表示为 R bps。假设主机 A 上的进程能够以 S bps 的速率向 TCP 套接字发送数据，其中 S = 10 x R。进一步假设 TCP 的接收缓存足够大，能够容纳整个文件，并且发送缓存只能容纳这个文件的百分之一。如何防止主机 A 上的进程连续地向 TCP 套接字以速率 S bps 传送数据呢？还是用 TCP 流量控制呢？还是用 TCP 拥塞控制呢？或者用其他措施？阐述其理由。

> 首先，由于接收方的接收缓存能容纳整个大文件，因此不会出现流量控制；并且因为在这条连接上不会出现任何分组丢失和定时器超时，因此拥塞控制机制不会遏制发送方的速率。最后，由于发送方的发送缓存会很快被填充满，因此一旦发送缓存被填充满，进程将无法继续以 S 速率向套接字发送数据，而是以 R 向套接字发送数据。

#### P44. 考虑从一台主机经一条没有丢包的 TCP 连接向另一台主机发送一个大文件。
#### a. 假定 TCP 不具有慢启动的 AIMD 进行拥塞控制。假设每当收到一批 ACK 时，cwnd 增加一个 MSS，并且假设往返时间大约恒定，cwnd 从 6MSS 增加到 12 MSS 要花费多长时间（假设没有丢包事件）？
#### b. 对于该连接，到时间 = 6RTT, 其平均吞吐量时多少？（根据 MSS 和 RTT）？

> a.
> 
> 7RTT
> 
> b.
> 
> 在第一个 RTT 内，发了 5 MSS 的分组，第二个 RTT 内，发了 6 MSS，所以总共是 5 + 6 + 7 + 8 + 9 + 10 = 45 MSS，所以平均吞吐量是 45 / 6 = 7.5 MSS/RTT

#### P45. 回想 TCP 吞吐量的宏观描述。在链接速率从 W/(2 x RTT) 变化到 W/RTT 的周期内，只丢失了一个分组（在该周期结束）。
#### a. 证明其丢包率（分组丢失的比率）等于：
	`L = 丢包率 = 1 / ( 3/8 x W^2 + 3/4 x W )`
#### b. 如果一条连接的丢包率为 L，使用上面的结果，则它的平均速率近似由下式给出：
	`平均速率 ~ 1.22 x MSS / (RTT x sqrt(L))`
> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p45.a.jpg)
> 
> b.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p45.b.jpg)
> 
> 由于 W 的单位是报文段的个数，如果最后平均速率是按字节计数，那么就再乘上每个报文段的大小 MSS 字节。

#### P46. 考虑仅有一条单一的 TCP (Reno) 连接使用一条 10 Mbps 的链路，且该链路没有缓存任何数据。假设这条链路是发送主机和接收主机之间的唯一拥塞链路。假定某 TCP 发送方向接收方有一个大文件要发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个 TCP 报文段长度为 1500 字节；该连接的双向传播时延是 150 ms；并且该 TCP 连接总是处于拥塞避免阶段，即忽略了慢启动。
#### a. 这条 TCP 连接能够取得的最大窗口长度（以报文段计）是多少？
#### b. 这条 TCP 连接的平均窗口长度（以报文段计）和平均吞吐量（以 bps 计）是多少？
#### c. 这条 TCP 连接从丢包恢复后，再次到达其最大窗口要经历多长时间？

> a.
> 
> 方法一：
> 
> 最大窗口也就是出现丢包前的窗口长度，如果发送速率超出了链路容量，那么分组可能会丢失，即 W x 1500 x 8 / 0.15 = 10^7 => W = 125 个
> 
> 方法二：
> 
> 若分组的发送时间大于 RTT，那么出现判定为超时丢包。即传输时延大于分组时延
> 
> L/R > 0.15 => L = 1500 x 10^3 bit，即 W = 1500 x 10^3 / (1500 x 8) = 125 个 
>
> b.
> 
> 我们知道一条连接的平均吞吐量为 0.75 x W / RTT，于是平均窗口长度为 0.75 x W = 0.75 x 125 = 94 个
> 
> 平均吞吐量为 94 x 1500 x 8 / 0.15 = 7.52 Mbps
> 
> c.
> 
> 每经过一个 RTT, 窗口就会增长 MSS，因此总共需要增长 W/2 个 RTT 才能恢复，即 W/2 x 0.15 = 94/2 x 0.15 = 7.05 s

#### P47. 考虑在前面习题中所描述的场景。假设 10 Mbps 链路能缓存有限个报文段。试论证为了使该链路总是忙于发送数据，我们将要选择缓存长度使其至少为发送方和接收方之间链路速率 C 与双向传播时延之积。

> 

#### P48. 重复习题 46, 但用一条 10 Gbps 链路代替 10 Mbps 链路。注意到在对 c 部分的答案中，应当认识到在从丢包恢复后，拥塞窗口长度到达最大窗口长度将需要很长时间。给出解决该问题的基本思路。

> a.
> 
> `W x 1500 x 8 / 0.15 = 10^10 => W = 1500 x 10^6 / (1500 x 8) = 125000`
> 
> b.
> 
> `平均窗口长度为 0.75 x 125000 = 93750`
> 
> `平均吞吐量为 93750 x 1500 x 8 / 0.15 = 7.5 Gbps` 
> 
> c.
> 
> 每经历 RTT，拥塞窗口长度增加一个 MSS，因此总共需要经历 `W/2` 个 RTT，即 `125000 / 2 * 0.15 = 9375 s = 156 min` 
> 
> 解决恢复拥塞窗口的长时间的问题，可以让拥塞窗口在每个 RTT 后以更快的步长增加，比如 ScalableTCP 和 HighSpeed TCP。

#### P49. 令 T (用 RTT 度量)表示一条 TCP 连接将拥塞窗口从 W/2 增加到 W  所需的时间间隔，其中 W 是最大的拥塞窗口长度。论证 T 是 TCP 平均吞吐量的函数。

#### P50. 考虑一种简化的 TCP 的 AIMD 算法，其中拥塞窗口长度用报文段的数量来度量，而不是用字节度量。在加性增重，每个 RTT 拥塞窗口长度增加一个报文段。在乘性减重，拥塞窗口长度减小一半（如果结果不是一个整数，向下取整到最近的整数）。假设两条 TCP 连接 C1 和 C2，它们共享一条速率为每秒 30 个报文段的单一拥塞链路。假设 C1 和 C2 均处于拥塞避免阶段。连接 C1 的 RTT 是 50 ms，连接 C2 的 RTT 是 100 ms。假设当链路中的数据速率超过了链路的速率时，所有 TCP 连接经受数据报文段丢失。
#### a. 如果在时刻 t0，C1 和 C2 具有 10 个报文段的拥塞窗口，在 1000 ms 后它们的拥塞窗口为多长？
#### b. 经长时间运行，这两条连接将取得共享该链路的相同的带宽吗？


