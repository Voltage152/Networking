### P28 ~ P39

#### P28. 主机 A 和 B 直接经一条 100 Mbps 链路连接。在这两台主机之间有一条 TCP 连接。主机 A 经这条连接向主机 B 发送一个大文件。主机 A 能够向它的 TCP 套接字以高达 120 Mbps 的速率发送应用数据，而主机 B 能够以最大 50 Mbsp 的速率从它的 TCP 接收缓存中读出数据。描述 TCP 流量控制的影响。

> 因为链路是 100 Mbps，所以 A 的发送速率最多是 100 Mbps，主机 B 以大约 40 Mbps 的速率充满接收缓存，当主机 B 接收缓存满了之后，主机 B 通知主机 A 停止发送数据，通过传送接收窗口置为 0 的 TCP 报文段。接下来主机 A 停止发送数据，而是不断得发送一个字节的报文段去探询主机 B 是否接收缓存中有空闲空间去接受数据。若某个确认报文段中接收窗口不是 0，那么主机 A 重新开始发送数据。长期平均的话，主机 A 的发送速率不会大于 60 Mbps。

#### P29. 在 3.5.6 节中讨论了 SYN cookie。
#### a. 服务器在 SYNACK 中使用一个特殊的初始序号，这为什么是必要的。
#### b. 假定某攻击者得知了一台目标主机使用了 SYN cookie。该攻击者能够通过直接向目标发送一个 ACK 分组创建半开或全开连接吗？为什么？
#### c. 假设某攻击者收集了由服务器发送的大量初始序号。该攻击者通过发送具有初始序号的 ACK，能够引起服务器产生许多全开连接吗？为什么？

> // TODO SYN cookie 洪泛攻击原理和防御
>
> a.
> 
> 为了抵御 SYN 洪泛攻击，原理: [SYN 洪泛攻击抵御原理](https://blog.csdn.net/bigtree_3721/article/details/77619119)
> 
> b.
> 
> 不能，因为 SYN cookie 是通过保存在服务器端的密码算出来的，而攻击者不知道该密码，因此无法伪造接下来的 ACK 中的 seq。
> 
> c.
> 
> 不能，因为服务器计算 SYN cookie 时可以加入时间戳作为参数，那么该 SYN cookie 便具有时效性，即便你发送了具有初始序号的 ACK，这些 SYN cookie 也已经过期了。

#### P30. 考虑在 3.6.1 节中显示第二种情况下的网络。假设发送主机 A 和 B 具有某些固定的超时值。
#### a. 证明增加路由器有限缓存的长度可能减小吞吐量。
#### b. 现在假设两台主机基于路由器的缓存时延，动态地调整它们的超时值（像 TCP 所做的那样）。增加缓存长度将有助于增加吞吐量吗？为什么？

> a.
> 
> 假设超时时间是固定的，增加路由器有限缓存，那么当流量强度接近 1 时，将会导致更长的分组队列，越往后的分组经历更大的排队时延，于是此时会发生什么情况呢，发送方 TCP 导致提前超时的可能性越来越大，尽管这些分组甚至都没有发送出去（它们还在排队呢），于是发送方 TCP 执行超时重传，这些提前超时的分组占用了本可以供给新分组发送的吞吐量。
> 
> b.
> 
> 如果动态调整超时值，当然可以增加发送方的吞吐量。但潜在问题是，也会造成越来越大的排队时延。

#### P31. 假设测量的 5 个 SampleRTT 值（参见 3.5.3 节）是 106 ms、120 ms、140 ms、90 ms 和 115 ms。在获得了每个 SampleRTT 值后计算 EstimatedRTT，使用 a = 0.125 并且假设在刚获得 5 个样本之后 EstimatedRTT 的值为 100 ms。在获得每个样本之后，也计算 DevRTT，假设 b = 0.25，并且假设在刚获得前 5 个样本之后 DevRTT 的值为 5 ms。最后，在获得这些样本之后计算 TCP TimeoutInterval。

> `EstimatedRTT = 0.875 x 100 ms + 0.125 x 106 ms = 100.75 ms`
> 
> `DevRTT = 0.75 x 5 ms + 0.25 x |100.75 - 106| = 5.065 ms`
> 
> `TimeoutInterval = EstimatedRTT + 4 x DevRTT = 100.75 + 4 x 5.065  = 121.01 ms`
> 
>  -------------------------------------------------------------
> 
> `EstimatedRTT = 0.875 x 100.75 ms + 0.125 x 120 ms = 103.15 ms`
> 
> `DevRTT = 0.75 x 5.065 ms + 0.25 x |103.15 - 120| = 20.64875 ms`
> 
> `TimeoutInterval = EstimatedRTT + 4 x DevRTT = 103.15 + 20.64875 = 185.744 ms`
> 
>  -------------------------------------------------------------
> 
> `EstimatedRTT = 0.875 x 103.15 ms + 0.125 x 140 ms = 107.76 ms`
> 
> `DevRTT = 0.75 x 20.64875 ms + 0.25 x |140 - 107.76| = 23.5465625 ms`
> 
> `TimeoutInterval = EstimatedRTT + 4 x DevRTT = 107.76 + 4 x 23.54 = 201.92 ms`
> 
>  -------------------------------------------------------------
> 
> `EstimatedRTT = 0.875 x 107.76 ms + 0.125 x 90 ms = 105.54 ms`
> 
> `DevRTT = 0.75 x 23.54 + 0.25 x |105.54 - 90| = 21.54 ms`
> 
> `TimeoutInterval = EstimatedRTT + 4 x DevRTT = 105.54 ms + 4 x 21.54 = 191.7 ms`
> 
>  -------------------------------------------------------------
> 
> `EstimatedRTT = 0.875 x 105.54 ms + 0.125 x 115 ms = 106.72 ms`
> 
> `DevRTT = 0.75 x 21.54 + 0.25 x |115 - 106.72| = 18.225`
> 
> `TimeoutInterval = EstimatedRTT + 4 x DevRTT = 106.72 + 4 x 18.225 = 179.62 ms`
> 
>  -------------------------------------------------------------

#### P32. 考虑 TCP 估计 RTT 的过程。假设 a = 0.1，令 SampleRTT1 设置为最新样本 RTT，令 SampleRTT2 设置为下一个最新样本 RTT，等等。
#### a. 对于一个给定的 TCP 连接，假定 4 个确认报文相继到达，带有 4 个对应的 RTT 值：SampleRTT4、SampleRTT3、SampleRTT2 和 SampleRTT1。根据这 4 个样本 RTT 表示 EstimatedRTT。
#### b. 将你的到的公式一般化到 n 个 RTT 样本的情况。
#### c. 对于在（b）中得到的公式，令 n 趋于无穷。试说明为什么这个平均过程被称为指数移动平均。

> a.
> 
> `EstimatedRTT1 = (1 - a)E0 + aS1`
> `EstimatedRTT2 = (1 - a)^2 x E0 + a(1 - a)S1 + aS2`
> `EstimatedRTT3 = (1 - a)^3 x E0 + a(1 - a)^2 x S1 + a(1 - a)S2 + aS3`
> `EstimatedRTT4 = (1 - a)^4 x E0 + a(1 - a)^3 x S1 + a(1 - a)^2 x S2 + a(1 - a)S3 + aS4`
> 
> 
> b.
> 
> `EstimatedRTTn = (1 - a)^n x E0 + a(1 - a)^(n-1) x S1 + ... + a(1 - a)Sn-1 + aSn`
> 
> c.
> 
> 

#### P33. 在 3.5.3 节中，我们讨论了 TCP 的往返时间估计。TCP 避免测量重传报文段的 SampleRTT，对此你有何看法？

#### P34. 3.5.4 节中的变量 SendBase 和 3.5.5 节中的变量 LastByteRevd 之间有什么关系?

#### P35. 3.5.5 节中的变量 LastByteRcvd 和 3.5.4 节中的变量 y 之间有什么关系?

#### P36. 在 3.5.4 节中，我们看到 TCP 直到收到 3 个冗余 ACK 才执行快速重传。你对 TCP 设计者没有选择在收到对报文段的第一个冗余 ACK 之后就快速重传有何看法？

#### P37. 比较 GBN、SR 和 TCP（无延时的 ACK）。假设对所有 3 个协议的超时值足够长，使得 5 个连续的数据报文段及其对应的 ACK 能够分别由主机（主机 B）和发送主机（主机 A）收到（如果在信道中无丢失）。假设主机 A 向主机 B 发送 5 个数据报文段，并且第二个报文段（从 A 发送）丢失。最后，所有 5 个数据报文段已经被主机 B 正确接收。
#### a. 主机 A 总共发送了多少报文段和主机 B 总共发送了多少 ACK？它们的序号是什么？对所有 3 个协议回答这个问题。
#### b. 如果对所有 3 个协议超时值比 5 RTT 长得多，则哪个协议在最短的时间间隔中成功地交付所有 5 个数据报文段？

#### P38. 在图 3-53 中的 TCP 描述中，阈值 ssthresh 的值在几个地方被设置为 ssthresh = cwnd / 2，并且当出现一个丢包事件时，ssthresh 的值被设置为窗口长度的一半。当出现丢包事件时，发送方发送的速率，每个 RTT 必须大约等于 cwnd 报文段吗？解释你的答案。如果你的回答是没有，你能建议一种不同的方式，进行 ssthresh 设置吗？

#### P39. 考虑图 3-46b。如果 