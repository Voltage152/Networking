### P1 ~ P18

#### P1. 假设客户 A 向服务器 S 发起一个 Telnet 会话。与此同时，客户 B 也向服务器 S 发起一个 Telnet 会话。给出下面报文段的源端口号和目的端口号：
#### a. 从 A 向 S 发送的报文段。
#### b. 从 B 向 S 发送的报文段。
#### c. 从 S 向 A 发送的报文段。
#### d. 从 S 向 B 发送的报文段。
#### e. 如果 A 和 B 是不同的主机，那么从 A 向 S 发送的报文段的源端口号是否可能与从 B 向 S 发送的报文段的源端口号相同？
#### f. 如果它们是同一台主机，情况会怎么样？

> 假设 A 的源端口号是 a, B 的源端口号是 b。
> 
> a.
> 
> 从 A 向 S 发送的报文段：(a, 23) 
> 
> b.
> 
> 从 B 向 S 发送的报文段：(b, 23)
> 
> c.
> 
> 从 S 向 A 发送的报文段：(23， a)
> 
> d.
> 
> 从 S 向 B 发送的报文段：(23, b)
> 
> e.
> 
> A, B 是不同主机的话， 那么 a 有可能等于 b，但是因为 TCP 套接字是根据四元组来标识的 `(dst_ip, dst_port, src_ip, src_port)`，而我们知道，主机 A 和 主机 B 的 IP 地址不会相同，因此相同端口号的报文段到达主机 S 仍然能被定位到不同的套接字中。
> 
> f.
> 
> 如果它们是同一台主机，那么源端口号不可能相同。

#### P2. 考虑图 3-5。从服务器返回客户进程的报文流中的源端口号和目的端口号是多少？在承载运输层报文段的数据报中，IP 地址是多少？

> 向主机 A 的返包中：(B, 80, A, 26145)、(B, 80, A, 7532)
> 
> 向主机 C 的返包中：(B, 80, C, 26145)

#### P3. UDP 和 TCP 使用反码来计算它们的校验和。假设你有下面 3 个 8 比特字节：01010011，01100110，01110100。这些 8 比特字节和的反码是多少？（注意到尽管 UDP 和 TCP 使用 16 比特的字来计算校验和，但对于这个问题，你应该考虑 8 比特和。）写出所有工作过程。UDP 为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？1 比特的差错将可能检测不出来吗？2 比特的差错呢？

> 第一问：这些 8 比特字节和的反码是多少？
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p3.1.png)
> 
> 答案： 1 1 0 1  0 0 0 1
> 
> 第二问：UDP 为什么要用该和的反码，为什么不直接使用该和呢？
> 
> 因为接收方的校验方式是把这原来的 3 个字节和 checksum 加在一块，看结果中是否有包含 0 比特位来判断是否出现差错。
> 
> 第三问：使用该反码方案，接收方如何检测出差错？
> 
> 若这 3 个字节和 checksum 加在一块的结果中包含 0 比特位，那么说明出现了比特位差错
> 
> ⚠️⚠️逐一第四问：1 比特的差错将可能检测不出来吗？2 比特的差错呢？
> 
> 1 比特差错一定会被检测出来，但是 2 比特的差错不一定能被检测出来。比如 
> 
> 第一个字节 0101 0011 --> 0101 0010 
> 第二个字节 0110 0110 --> 0101 0111
> 
> 上面两个字节的最后一个比特位交换位置，这样的话，加和不会改变。所以 checksum 也不会发生改变。

#### P4. 
#### a. 假定你有下列 2 个字节：0101 1100 和 0110 0101。这两个字节之和的反码是什么？
#### b. 假定你有下列 2 个字节：1101 1010 和 0110 0101。这两个字节之和的反码是什么？
#### c. 对于（a）中的字节，给出一个例子，使得这两个字节中的每一个都在一个比特反转时，其反码不会改变。

> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p4.1.png)
> 
> b.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p4.2.png)
> 
> c.
> 
> `0101 1100`
> 
> `0110 0101`
> 
> 交换两个字节的第 5 个比特位，变为
> 
> `0100 1100`
> 
> `0111 0101`
> 
> 这样加和不会变，自然反码也不会变

#### P5. 假定某 UDP 接收方对接收到的 UDP 报文段计算因特网校验和，并发现它与承载在校验和字段中的值相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。

> 不能，两个字节相加时，如果对应的比特位调换位置，加和并不会发生改变，比如 0001 和 0010 变为 0011 和 0000，加和都是 0011，如 P3 所说，一个比特位的差错可以被校验出来，但是两个比特位的差错不一定能被校验出来。

#### P6. 考虑我们改正协议 rdt 2.1 的动机。试说明如图 3-57 所示的接收方与如图 3-11 所示的发送方运行时，接收方可能会引起发送方和接收方进入死锁状态，即双方都在等待不可能发生的事件。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p6.png)
> 
> 假设发送方发来分组 0，接收方正确接收到该分组 0，并给发送方回传 ACK 作为确认，但该 ACK 抵达发送方前损坏，于是发送方重传分组 0，当接收方正确接收到该分组 0 时，接收方处于 wait 1 状态，于是给发送方回传 NAK。此时进入死锁，无论发送方是否正确接收到该 NAK，都会重传分组 0，无论接收方是否正确接收该分组 0，都会回传 NAK。

#### P7. 在 rdt 3.0 协议中，从接收方向发送方流动的 ACK 分组没有序号（尽管它们具有 ACK 字段，该字段包括了它们正在确认的分组的序号）。为什么这些 ACK 分组不需要序号呢？

> 接收方需要分组序号是因为接收方无法确认自己的 ACK 能否正确到达发送方，因此无法确认发送方是重传分组还是新分组。但发送方并不需要辨认 ACK 是重传还是新的 ACK，只要是 ACK，发送方就会进入到下一个状态等待上层调用，冗余的 ACK 被忽略。

#### P8. 画出协议 rdt 3.0 接收方的 FSM。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p8.png)

#### P9. 当数据分组和确认分组发生篡改时，给出 rdt 3.0 协议运行的轨迹。你画出的轨迹应当类似于图 3-16 中所用的图。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p9.png)

#### P10. 考虑一个能够丢失分组但其最大时延已知的信道。修改协议 rdt 2.1 ，以包括发送方超时和重传机制。非正式地论证：为什么你的协议能够通过该信道正确通信？

> 原来的 rdt 2.1 如下图所示
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p10.1.png)
> 
> 添加了超时和重传机制的 rdt 2.1 如下图所示
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p10.2.png)
> 
> 为什么我的协议能够通过该信道正确通信？
> 
> 1、由于最大时延已知，所以我可以将定时器的超时事件设置为大于最大超时时延，于是发送方永远不会提前超时，所以发送方不会在 wait 0 或者 wait 1 状态接收到分组。
> 
> 2、对于接收方，若此时在等待分组 0 到达，因为发送方不会提前超时，所以在分组 0 到达后再来一个分组 0 只可能发生在发送方没有正确接收到 ACK 的情况下出现。此时只需重传 ACK。

#### P11. 考虑在图 3-14 中的 rdt 2.2 接收方，在状态 “等待来自下层的 0” 和状态 “等待来自下层的 1” 中的自转换（即从某状态转换回自身）中生成一个新分组：sndpk = make_pkt(ACK, 1, checksum) 和 sndpk = make_pkt(ACK, 0, checksum)。如果这个动作从状态 “等待来自下层的 1” 中的自转换中删除，该协议将正确工作吗？评估你的答案。在状态 ”等待来自下层的 0“ 中的自转换中删除这个事件将会怎样？【提示：在后一种情况下，考虑如果第一个发送方到达接收方的分组损坏的话，将会发生什么情况？】

> 这当然是无法正常工作的咯....若发送方发送了一个分组 0，但是这个包到达接收方时损坏了，此时 rdt 2.2 接收方没啥反应，而发送方在等一个 ACK 0 的确认，于是造成死锁。后一种情况也一样。

#### P12. rdt 3.0 协议的发送方直接忽略（即不采取任何动作）接收到的所有出现差错和确认分组的确认号（acknum）字段中的值有差错的分组。假设在这种情况下，rdt 3.0 只是重传当前的数据分组，该协议是否还能正常运行？（提示：考虑在下列情况下会发生什么情况：仅有一个比特差错时；报文没有丢失但能出现定时器过早超时。考虑到当 n 趋于无穷时，第 n 个分组将被发送多少次。）

> 该协议还能正常运行。
> 
> ⚠️⚠️⚠️ 没太想清楚
> 
> 若发送方接收到错包时就重传分组，那么如果接收方一直没有收到正确的包，发送方就会一直发，因此第 n 个分组将会被发送无数次。

#### P13. 考虑 rdt 3.0 协议。如果发送方和接收方网络能够对报文重排序（即在发送方和接收方之间的媒体上传播的两个报文段能重新排序），那么比特交替协议将不能正确工作（确信你清楚地理解这时它不能正确工作的原因），试画图说明之。画图时把发送方放在左边，接收方放在右边，使时间轴朝下，标出交换的数据报文（D）和确认报文（A）。要标明与任何数据和确认报文段相关的序号。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p13.png)

#### P14. 考虑一种仅使用否定确认的可靠数据传输协议。假定发送方只是偶尔发送数据。只用 NAK 的协议是否会比使用 ACK 的协议更好？为什么？现在我们假设发送方要发送大量的数据，并且该端到端连接很少丢包。在第二种情况下，只用 NAK 的协议是否会比使用 ACK 的协议更好？为什么？

> //TODO
> 
> ⚠️⚠️⚠️ 没想明白仅使用否定确认的可靠数据传输协议如何实现？？？
> 
> 在只采用否定确认的协议中，分组 x 的丢失只有当分组 x + 1 被接收方收到后才能发现，如果 x 和 x + 1 之间有很长的时延的话，那么分组 x 必须经历很长的时延才能被恢复。
> 
> 如果发送方要发送大量数据，并且很少丢包，那么仅使用 NAK 的协议更好，因为分组 x 的丢失能很快被恢复（因为发送方发包很频繁），并且减少了大量 ACK 的确认，而 NAK 只占很少的一部分（因为题目假设端到端很少丢包）

#### P15. 考虑如图 3.17 所示的跨国示例，当信道利用率要大于 98% 时窗口尺寸需要变多大？假定一个分组的尺寸是 1500 字节（包括首部字段和应用数据）。

> 假设 `R = 1 Gbps`，传播时延 `RTT = 30 ms`
> 
> 计算传输时延为 `T_trans = L / R = 1500 x 8 / 10^9 = 0.000012 s = 0.012 ms = 12 us`
> 
> 由 `U_sender = win_size / ( (RTT / (L/R) + 1 ) = 0.98` 得到：
> 
> `win_size = 2450.98 ~ 2450`

#### P16. 假设某应用使用 rdt 3.0 作为运输层协议。因为停等协议具有非常低的信道利用率（显示在网络跨越国家的例子中），该应用程序的设计者让接收方持续回送许多（大于2）交替的 ACK 0 和 ACK 1，即使对应的数据未到达接收方。这个应用程序设计将能增加信道利用率吗？为什么？该方法存在某种潜在的问题吗？试解释之。

> 能增加信道利用率。毕竟发送方接收到 0 或者 1 就会转出到 `rdt_send(data)` 状态发送分组。潜在的问题是：接收方并没有真正接收到很多分组，而这些提前透支的 ACK 0 或者 ACK 1 可能并不能正确接收到对应的分组。

#### P17. 考虑两个网络实体 A 和 B，它们由一条完善的双向信道所连接（即任何发送的报文将正确地收到；信道将不会损坏、丢失或重排序分组）。A 和 B 将以交互的方式彼此交付报文：首先，A 必须向 B 交付一个报文，B 然后必须向 A 交付一个报文，接下来 A 必须向 B 交付一个报文，等等。如果一个实体处于它不试图向另一侧交付报文的状态，将存在一个来自上层的类似于 `rdt_send(data)` 调用的事件，它试图向下传递数据以向另一侧传输，来自上层的该调用能够直接忽略对于 `rdt_unable_to_send(data)` 调用，这通知较高层当前不能够发送数据。【注意：做出这种简化的假设，使你不必担心缓存数据。】
#### 对该协议画出 FSM 说明（一个 FSM 用于 A, 一个 FSM 用于 B）。注意你不必担心这里的可靠性机制，该问题的要点在于创建反映这两个实体的同步行为的 FSM 说明。应当使用与图 3-9 中协议 rdt 1.0 有相同含义的下列事件和动作：`rdt_send(data)`, `packet = make_pkt(data)`, `udt_send(data)`, `rdt_rct(packet)`, `extract(packet, data)`, `deliver_data(data)`。保证你的协议反映了 A 和 B 之间发送的严格交替。还要保证你的 FSM 描述中指出 A 和 B 的初始状态。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p17.png)

#### P18. 在 3.4.4. 节我们学习的一般性 SR 协议中，只要报文可用（如果报文在窗口中），发送方就会不等待确认而传输报文。假设现在我们要求一个 SR 协议，一次发出一对报文，而且只有在知道第一对报文中的两个报文都正确到达后才发送第二对报文。
#### 假设该信道中可能会丢失报文，但报文不会发生损坏和失序。试为报文的单向可靠传输而设计一个差错控制协议。画出发送方和接送方的 FSM 描述。描述在发送方和接收方之间两个方向发送的报文格式。如果你使用了不同于 3.4 节（例如 `udt_send()`、`start_timer()`、`rdt_rcv()` 等）中的任何其他过程调用，详细地阐述这些动作。举例说明（用于发送方和接收方的时序踪迹图）你的协议是如何恢复报文丢失的。

>
> 下图是一般性的 SR 协议：
>
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p18.1.png)
> 
> 下图是按照题目要求重新设计的 SR 协议：
> 
> 
