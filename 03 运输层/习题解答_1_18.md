### P1 ~ P18

#### P1. 假设客户 A 向服务器 S 发起一个 Telnet 会话。与此同时，客户 B 也向服务器 S 发起一个 Telnet 会话。给出下面报文段的源端口号和目的端口号：
#### a. 从 A 向 S 发送的报文段。
#### b. 从 B 向 S 发送的报文段。
#### c. 从 S 向 A 发送的报文段。
#### d. 从 S 向 B 发送的报文段。
#### e. 如果 A 和 B 是不同的主机，那么从 A 向 S 发送的报文段的源端口号是否可能与从 B 向 S 发送的报文段的源端口号相同？
#### f. 如果它们是同一台主机，情况会怎么样？

> 假设 A 的源端口号是 a, B 的源端口号是 b。
> 
> a.
> 
> 从 A 向 S 发送的报文段：(a, 23) 
> 
> b.
> 
> 从 B 向 S 发送的报文段：(b, 23)
> 
> c.
> 
> 从 S 向 A 发送的报文段：(23， a)
> 
> d.
> 
> 从 S 向 B 发送的报文段：(23, b)
> 
> e.
> 
> A, B 是不同主机的话， 那么 a 有可能等于 b，但是因为 TCP 套接字是根据四元组来标识的 `(dst_ip, dst_port, src_ip, src_port)`，而我们知道，主机 A 和 主机 B 的 IP 地址不会相同，因此相同端口号的报文段到达主机 S 仍然能被定位到不同的套接字中。
> 
> f.
> 
> 如果它们是同一台主机，那么源端口号不可能相同。

#### P2. 考虑图 3-5。从服务器返回客户进程的报文流中的源端口号和目的端口号是多少？在承载运输层报文段的数据报中，IP 地址是多少？

> 向主机 A 的返包中：(B, 80, A, 26145)、(B, 80, A, 7532)
> 
> 向主机 C 的返包中：(B, 80, C, 26145)

#### P3. UDP 和 TCP 使用反码来计算它们的校验和。假设你有下面 3 个 8 比特字节：01010011，01100110，01110100。这些 8 比特字节和的反码是多少？（注意到尽管 UDP 和 TCP 使用 16 比特的字来计算校验和，但对于这个问题，你应该考虑 8 比特和。）写出所有工作过程。UDP 为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？1 比特的差错将可能检测不出来吗？2 比特的差错呢？

> 第一问：这些 8 比特字节和的反码是多少？
> 
> 答案： 1 1 0 1  0 0 0 1
> 
> 第二问：UDP 为什么要用该和的反码，为什么不直接使用该和呢？
> 
> 因为接收方的校验方式是把这原来的 3 个字节和 checksum 加在一块，看结果中是否有包含 0 比特位来判断是否出现差错。
> 
> 第三问：使用该反码方案，接收方如何检测出差错？
> 
> 若这 3 个字节和 checksum 加在一块的结果中包含 0 比特位，那么说明出现了比特位差错
> 
> ⚠️⚠️逐一第四问：1 比特的差错将可能检测不出来吗？2 比特的差错呢？
> 
> 1 比特差错一定会被检测出来，但是 2 比特的差错不一定能被检测出来。比如 
> 
> 第一个字节 0101 0011 --> 0101 0010 
> 第二个字节 0110 0110 --> 0101 0111
> 
> 上面两个字节的最后一个比特位交换位置，这样的话，加和不会改变。所以 checksum 也不会发生改变。

#### P4. 
#### a. 假定你有下列 2 个字节：0101 1100 和 0110 0101。这两个字节之和的反码是什么？
#### b. 假定你有下列 2 个字节：1101 1010 和 0110 0101。这两个字节之和的反码是什么？
#### c. 对于（a）中的字节，给出一个例子，使得这两个字节中的每一个都在一个比特反转时，其反码不会改变。

> a.
> 
> 
> 
> b.
> 
> 
> c.
> 
> `0101 1100`
> 
> `0110 0101`
> 
> 交换两个字节的第 5 个比特位，变为
> 
> `0100 1100`
> 
> `0111 0101`
> 
> 这样加和不会变，自然反码也不会变

#### P5. 假定某 UDP 接收方对接收到的 UDP 报文段计算因特网校验和，并发现它与承载在校验和字段中的值相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。

> 不能，两个字节相加时，如果对应的比特位调换位置，加和并不会发生改变，比如 0001 和 0010 变为 0011 和 0000，加和都是 0011，如 P3 所说，一个比特位的差错可以被校验出来，但是两个比特位的差错不一定能被校验出来。

#### P6. 考虑我们改正协议 rdt 2.1 的动机。试说明如图 3-57 所示的接收方与如图 3-11 所示的发送方运行时，接收方可能会引起发送方和接收方进入死锁状态，即双方都在等待不可能发生的事件。

> 

#### P7. 在 rdt 3.0 协议中，从接收方向发送方流动的 ACK 分组没有序号（尽管它们具有 ACK 字段，该字段包括了它们正在确认的分组的序号）。为什么这些 ACK 分组不需要序号呢？

#### P8. 画出协议 rdt 3.0 接收方的 FSM。

#### P9. 当数据分组和确认分组发生篡改时，给出 rdt 3.0 协议运行的轨迹。你画出的轨迹应当类似于图 3-16 中所用的图。
