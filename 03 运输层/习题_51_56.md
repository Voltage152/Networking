### P51 ~ P56

#### P51. 考虑在前面习题中描述的网络。现在假设两条 TCP 连接 C1 和 C2, 它们具有相同的 100 ms RTT。假设在时刻 t0, C1 的拥塞窗口长度为 15 个报文段，而 C2 的拥塞窗口长度是 10 个报文段。
#### a. 在 2200 ms 后，它们的拥塞窗口长度为多长？
#### b. 经长时间运行，这两条连接将取得共享该拥塞链路的相同的带宽吗？
#### c. 如果这两条连接在相同时间达到它们的最大窗口长度，并在相同时间达到它们的最小窗口长度，我们说这两条连接是同步的。经长时间运行，这两条连接将最终变得同步吗？如果是，它们的最大窗口长度是多少？
#### d. 这种同步将有助于改善共享链路的利用率吗？为什么？给出打破这种同步的某种思路。

> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p51.png)
> 
> C1 和 C2 都在 10 ~ 20 的波动
> 
> b.
> 
> 能，因为该 TCP 采用 AIMD 算法并且具有相同的 RTT。
> 
> c.
> 
> 会变得同步，最大窗口长度是 2
> 
> d.
> 
> 不会有助于改善链路的利用率，因为速率在 20 ~ 40 之间波动，当路由器是有限缓存（为啥？⚠️⚠️⚠️）时，并且丢包是任意情况下，会打破该同步，因为她们将在不同的时间点改变窗口大小。

#### P52. 考虑修改 TCP 的拥塞控制算法。不使用加性增，使用乘性增。无论何时某 TCP 收到一个合法的 ACK, 就将其窗口长度增加一个小正数 a（0 < a < 1）。求出丢包率 L 和最大拥塞窗口 W 之间的函数关系。论证：对于这种修正的 TCP, 无论 TCP 的平均吞吐量如何，一条 TCP 连接将其拥塞窗口长度从 W/2 增加到 W, 总是需要相同的时间。

> 设 S 为窗口从 W/2 增加到 W 期间发送的总报文段数目，因此有
> 
> `S = W/2[ 1 + (1 + a) + (1 + a)^2 + ... + (1 + a)^k ] = W/2[((a + 1)^(k+1) - 1) / a]`
> 
> 由 `k = log(a+1, 2)` 得到
> 
> `S = W(2a + 1)/(2a)`
> 
> 由 `L = 1/S = 2a/(W(2a + 1))`
> 
> 窗口由 W/2 增加到 W 期间所经历的时间 T 为 `kRTT = log(a+1, 2)RTT`
> 
> 因此该 TCP 的平均吞吐量为 `S/T = 1/(kLRTT)` 以 MSS 为单位。

#### P53. 在 3.7 节对 TCP 未来的讨论中，我们注意到为了取得 10 Gbps 的吞吐量，TCP 仅能容忍 2 x 10^-10 的报文段丢失率（或等价为每 5 000 000 000 个报文段有一个丢包事件）。给出针对 3.7 节中给定的 RTT 和 MSS 值的对 2 x 10^10 值的推导。如果 TCP 需要支持一条 100 Gbps 的连接，所能容忍的丢包率是多少？

> 
> `平均吞吐量 = 1.22 x MSS / (RTT x sqrt(L)) = 10^10`
> 
> 假定 RTT 是 100 ms, 并且 MSS 是 1500 字节，那么 `sqrt(L) = 1.22 x 1500 x 8 / (0.1 x 10^10) = 0.00001464`
> 
> 则 `L = 0.00001464 x 0.00001464 = 0.0000000002`
> 
> 如果需要支持一条 100 Gbps 的连接，能容忍的丢包率是：
> 
> `sqrt(L) = 1.22 x MSS / (RTT x B) = 1.22 x 1500 x 8 / (0.1 x 10^11) = 0.000000000002`
> 
> 即每 5 千亿个包中有一个丢失

#### P54. 在 3.7 节中对 TCP 拥塞控制的讨论中，我们隐含地假定 TCP 发送方总是有数据要发送。现在考虑下列情况，某 TCP 发送方发送大量数据，然后在 t1 时刻变得空闲（因为它没有更多的数据要发送）。TCP 在相对长的时间内保持空闲，然后在 t2 时刻要发送更多的数据。当 TCP 在 t2 开始发送数据时，让它使用在 t1 时刻的 cwnd 和 ssthresh 值，将有什么样的优点和缺点？你建议使用什么样的方法？为什么？

> 优点：
> 
> 不需要重新经历慢启动就能达到 t1 时的拥塞窗口和吞吐量
> 
> 缺点：
> 
> 此方法使 TCP 的拥塞控制不再精确，特别是假如 t1 ~ t2 之间链路变得很拥塞，那么该方法将会雪上加霜的在不堪负重的链路中施加压力。

#### P55. 在这个习题中我们研究是否 UDP 或 TCP 提供了某种程序的端点鉴别。
#### a. 考虑一台服务器接收到在一个 UDP 分组中的请求并对该请求进行响应（例如, 如由 DNS 服务器所做的那样）。如果一个具有 IP 地址 X 的客户用地址 Y 进行哄骗的话，服务器将向何处发送它的响应？
#### b. 假定一台服务器接收到具有 IP 源地址 Y 的一个 SYN，在用 SYNACK 响应之后，接受一个具有 IP 源地址 Y 和正确确认号的 ACK。假设该服务器选择了一个随机初始序号并且没有 “中间人”，该服务器能够确定该客户的确位于 Y 吗？（并且不再某个其他哄骗 Y 的地址 X）。

> a.
> 
> 服务器将向 Y 发送它的响应
> 
> b.
> 
> 该服务器能够确定该客户的确位于 Y，因为服务器在 SYNACK 中使用了特殊的 cookie 序号，能将此序号加 1 作为确认号在一定时间内发过来的客户一定是的确位于 Y （假设没有中间人）。

#### P56. 在这个习题中，我们考虑由 TCP 慢启动阶段引入的时延。考虑一个客户和一个 Web 服务器直接连接到速率为 R 的一条链路。假定该客户要取回一个对象，其长度正好等于 15 S，其中 S 是最大报文段长度(MSS)。客户和服务器之间的往返时间表示为 RTT（假设为常数）。忽略协议首部，确定在下列情况下取回该对象的时间（包括 TCP 连接创建）：
#### a. 4S/R > S/R + RTT > 2S/R
#### b. S/R + RTT > 4S/R
#### c. S/R > RTT

> a.
> 
> 对于 a 中的条件，变形后得到 `3S/R > RTT > S/R`
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p56.1.png)
> 
> b.
> 
> 对于 b 中的条件，变形后得到 `RTT > 3S/R`
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p56.2.png)
> 
> c.
> 
> 对于 c 中的条件，变形后得到 `S/R > RTT` 
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p56.3.png)
> 