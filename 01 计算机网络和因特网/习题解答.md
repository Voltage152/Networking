#### P1  设计并描述在自动柜员机和银行的中央计算机之间使用的一种应用层协议。你的协议应当允许验证用户卡和口令，查询账目结算（这些都在中央计算机系统中进行维护），支取账目（即向用户支付钱），你的协议实体应当能够处理取钱时账目中钱不够的常见问题。通过列出自动柜员机和银行中央计算机在报文传输和接收过程中交换的报文和采取的动作来定义你的协议。使用类似于图 1-2 所示的图，拟定在简单无差错取钱情况下该协议的操作。明确地阐述在该协议中关于底层端到端运输服务所作的假设。


	Request
	    Command : xxxx
	    Parameter : xxx
	
	Response
	    ClientOpResult : xxx
	    ATMOp : xxx
	    Message : xxx
	
	
	        ATM                                                  Bank
	----------------------------------------------------------------------------------
	Command : WithdrawMoney
	Parameter : NULL    ---------------------->
	
	                    <---------------------- OpResult : OK
	                                            Message : Enter Your Name And Password
	                                            ATMOp : DisplayMessage | ReadInput
	Command : InputNameAndPassword
	Parameter : Hanson&123 -------------------> 
	                                            OpResult : Ok
	                                            Message : Check Success, Please Enter Amount
	                                            ATMOp : DisplayMessage | ReadInput
	                    <----------------------
	Command : InputAmount
	Parameter : 1000    ----------------------> 
	                                            OnResult : OK
	                                            Message : Enough, Here you are, Bye
	                                            ATMOp : DisplayMessage | Counting
	
	
	
	        ATM                                                  Bank
	----------------------------------------------------------------------------------
	Command : WithDrawMoney
	Parameter : NULL    ---------------------->
	
	                    <---------------------- OpResult : OK
	                                            Message : Enter Your Name And Password
	                                            ATMOp : DisplayMessage | ReadInput
	Command : InputNameAndPassword
	Parameter : Hanson&123 -------------------> 
	                                            OpResult : Ok
	                                            Message : Check Success, Please Enter Amount
	                                            ATMOp : DisplayMessage | ReadInput
	                    <----------------------
	Command : InputAmount
	Parameter : 1000    ----------------------> 
	                                            OnResult : Fail
	                                            Message : Not Enough, Bye
	                                            ATMOp : DisplayMessage | Exit
	                                            

#### P2 式 (1-1) 给出了经传输速率为 R 的 N 段链路发送长度 L 的一个分组的端到端时延。对于经过 N 段链路连续发送 P 个这样的分组，一般化地表示出这个公式。

> T = (N + P - 1) / R
> 
> N * L / R 秒后，第一个分组到达目的主机，此时第二个分组到达了最后一个路由，又经过 L / R 秒后，第二个分组到达目的主机，以此类推。

#### P3 考虑一个应用程序以稳定的速率传输数据（例如，发送方每 k 个时间单元产生一个 N 比特的数据单元，其中 k 较小且固定）。另外，当这个应用程序启动时，它将连续运行相当长的一段时间。回答下列问题，简要论述你的回答：
##### a. 是分组交换还是电路交换更为适合这种应用，为什么？
##### b. 假定使用了分组交换网，并且该网中的所有流量都来自如上所述的这种应用程序。此外，假定该应用程序数据传输速率的总和小于每条链路的各自容量。需要某种形式的拥塞控制吗？为什么？

> a.
> 
> 电路交换更适合这种应用；
> 
> *	 发送方速率恒定，即发送方不会闲置带宽
> *	 发送方速率稳定且没有突发性质的分组，即使用不会超出预置带宽
> * 程序启动后将运行相当长的一段时间，即启动预分配电路和资源的时间被运行时间分摊
> 
> b.
> 
> 不需要；
> 
> * 发送方传输速率的总和小于每条链路的各自容量，所以流量强度小于 1，即输出队列长度不会无界增加
> * 假设发送速率为 L 分组/s，传输速率为 R 分组/s，每隔 L/R 秒发送 1 分组数据，那么每个分组将没有排队时延，假如每隔 N * L/R （**题目已经说了 k  较小，如果 k 很大，因为现实世界输出缓存有容量限制，那么可能一开始就有丢包**）秒发送 N 分组数据，虽然除了第一个分组外每个分组都有一定的排队时延，但是在 N * L/R 秒内这些分组将全部被推上下一条链路而不会让队列长度继续增加，所以不会出现丢包现象。
> 

#### P4 考虑在图 1-13 中的电路交换网。回想在每条链路上有 4 条链路，以顺时针方向标记四台交换机 A、B、C 和 D。
#### a. 在该网络中，任何时候能够进行同时连接的最大数量是多少？
#### b. 假定所有连接位于交换机 A 和 C 之间。能够进行同时连接的最大数量是多少？
#### c. 假定我们要在交换机 A 和 C 之间建立 4 条连接，在交换机 B 和 D 之间建立另外 4 条连接。我们能够让这些呼叫通过这 4 条链路建立路由以容纳所有这 8 条连接吗？

> a.
> 
> ~~8~~
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p4.1.png)
> 
> 由上述图表示，任何时候能够同时进行连接的数量是 16 个。
> 
> b.
> 
> ~~4~~
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p4.2.png)
> 
> 由上述图表示，A 和 C 之间能够进行同时连接的最大数量是 8
> 
> c.
> 
> ~~不能~~
> 
> 能
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p4.3.png)
> 由上述图表示

#### P5 回顾在 1.4 节中的车队的类比。假定传播速度还是 100 km/h。
#### a. 假定车队旅行 150km: 在一个收费站前面开始，通过第二个收费站，并且在第三个收费站后面结束。其端到端的时延是多少？
#### b. 重复（a）, 现在假定车队中有 8 辆汽车而不是 10 辆。

> a.
> 
> 车队旅行 150 km，每个收费站间相隔 75 km，传播时延需要 45 分钟。
> 假设收费站服务每辆车时间为 12 s，那么 10 辆车总共需要 2 分钟。
> 提前到达收费站的车辆需要等待最后一辆车到达才能开始接收服务。
> 
> T = (2 + 45) x 2 + 2 = 96 分钟
> 
> b.
> 
> T = (1.6 + 45) x 2 + 1.6 = 94.8 分钟 = 94 分钟 48 s

#### P6 这个习题开始探讨传播时延和传输时延，这是数据网络中的两个重要概念。考虑两台主机 A 和 B 由一条速率为  R bps 的链路相连。假定这两台主机相隔 m 米，沿该链路的传播速率为 s m/s。主机 A 向主机 B 发送长度为 L 比特的分组。
#### a. 用 m 和 s 来表示传播时延 `d_prop`
#### b. 用 L 和 R 来确定该分组的传输时间 `d_trans`。
#### c. 忽略处理和排队时延，得到端到端时延的表达式。
#### d. 假定主机 A 在时刻 t = 0 开始传输该分组。在时刻 t = `d_trans`，该分组的最后一个比特在什么地方？
#### e. 假定 `d_prop` 大于 `d_trans`。在时刻 t = `d_trans`，该分组的第一个比特在何处？
#### f. 假定 `d_proc` 小于 `d_trans`。在时刻 t = `d_trans`，该分组的第一个比特在何处？
#### g. 假定 s = 2.5 x 10^8，L = 120 比特，R = 56 kbps。求出使 `d_proc` 等于 `d_trans` 的距离 m。

> a.
> 
> `d_prop` = `m / s`
> 
> b.
> 
> `d_trans` = `L / R`
> 
> c.
> 
> `T_端_to_端` = `d_prop + d_trans = m / s + L / R`
> 
> d.
> 
> 该分组的最后一个比特刚刚被推上链路准备开始传送
> 
> e.
> 
> 第一个比特在链路上被传送了 `(L - 1) x R x s` 米，还没有到达 B。
> 
> f.
> 
> t = `0`，开始处理第一个比特
> 
> t = `1 / R`，第一个比特被推上了链路
> 
> t = `1 / R + m / s`，第一个比特到达 B 
> 
> t = `L / R`，最后一个比特被推上了链路
> 
> 第一个比特已经到达 B ，并且等待了 `(L - 1) / R - m / s` 秒
> 
> g.
> 
> m = `L * s / R` = 535714 m = 535 公里

#### P7 在这个习题中，我们考虑从主机 A 向主机 B 通过分组交换网发送语音 (VoIP)。主机 A 将模拟语音转换为传输中的 64 kbps 数字比特流。然后主机 A 将这些比特分为 56 字节的分组。A 和 B 之间有一条链路：它的传输速率是 2 Mbps，传播时延是 10 ms。一旦 A 收集了一个分组，就将它向主机 B 发送。一旦主机 B 接收到一个完整的分组，它将该分组的比特转换成模拟信号。从比特产生（从位于主机 A 的初始模拟信号起）的时刻起，到该比特被解码（在主机 B 上作为模拟信号的一部分），花了多少时间？

> ~~T = (56 x 8) / (2 x 10^6) x 10^3 + 10 = 10.224 ms~~
> 
> A 开始传送分组前，分组中的所有比特都应该已生成，而生成一个分组的所有比特所需的时间为 56 x 8 / (64 x 10^3) = 7 ms
> 再加上传输时延和传播时延为 7 ms + 10.224 ms = 17.224 ms

#### P8 假定用户共享一条 3 Mbps 的链路。又设每个用户传输时要求 150 kbps，但是每个用户仅有 10% 的时间传输。（参见 1.3 节中关于 "分组交换与电路交换的对比" 讨论）
#### a. 当使用电路交换时，能够支持多少用户？
#### b. 对于本习题的后续小题，假定使用分组交换。求出给定用户正在传输的概率。
#### c. 假定有 120 个用户。求出在任何给定时刻，实际有 n 个用户在同时传输的概率。
#### d. 求出有 21 个或更多用户同时传输的概率。

> a.
> 
> 当使用电路交换时能支持的用户数量为：`3 x 10^3 / 150 = 20` 个
> 
> b.
> 
> 每个用户仅有 10% 的时间传输，即给定用户正在传输的概率为 0.1
> 
> c.
> 
> `C(120,n) x 0.1^n x 0.9^(120 - n)`
> 
> d.
> 
> `P(X >= 21) = 1 - P(X < 21)`
> 
> //TODO 概率论与数理统计 - 陈希儒

#### P9 考虑在 1.3 节 "分组交换与电路交换的对比" 的讨论中，给出了一个具有一条 1 Mbps 链路的例子。用户在忙时以 100 kbps 速率产生数据，但忙时仅以 p = 0.1 的概率产生数据。假定用 1 Gbps 链路替代 1 Mbps 的链路。
#### a. 当采用电路交换技术时，能被同时支持的最大用户数量 N 是多少？
#### b. 现在考虑分组交换和有 M 个用户的情况。给出多于 N 用户发送数据的概率公式（用 p、 M、N 表示）

> a.
> 
> `N = 10^6 kbps / 10^2 kbps = 1 万用户`
> 
> b.
> 
> `P (X = N + 1) = C(M, N + 1) x p^(N + 1) x (1 - p)^(M - N - 1)`
> `P (X > N) = P(X = N + 1) + P(X = N + 2) + ... P(X = M)`
> 
> //TODO 概率论与数理统计 - 陈希儒

#### P10 考虑一个长度为 L 的分组从端系统 A 开始。经 3 段链路传送到目的端系统。令 di、si 和 Ri 表示链路 i 的长度、传播速度和传输速率（i = 1，2，3）。该分组交换机对每个分组的时延为 `d_proc`。假定没有排队时延，根据 di、si、Ri(i = 1, 2, 3) 和 L，该分组总的端到端时延是什么？现在假定该分组是 1500 字节，在所有 3 条链路上的传播时延是 2.5 x 10^8 m/s，所有 3 条链路的传输速率是 2 Mbps，分组交换机的处理时延是 3 ms，第一段链路的长度是 5000 km，第二段链路的长度是 4000 km，并且最后一段链路的长度是 1000 km。对于这些值，该端到端时延为多少？

> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p10.png)
> 
> `T_端_to_端 = L/R1 + d1/s1 + L/R2 + d2/s2 + L/R3 + d3/s3 + 2 x d_proc`
> 
> `L/R = 1.2 x 10^4 x 10^3 / (2 x 10^6) = 6 ms`
> `传播时延 = 10^7 x 10^3 / (2.5 x 10^8) = 40 ms`
> `处理时延 = 3 x 2 = 6 ms`
> `T_端_to_端 = 6 x 3 + 6 + 40 = 64 ms`

#### P11 在上述习题中，假定 R1 = R2 = R3 = R 且 `d_proc` = 0。进一步假定该分组交换机不存储转发分组，而是在等待分组到达前立即传输它收到的每个比特。这时端到端处理时延为多少？

> `T_端_to_端 = L/R + d1/s1 + d2/s2 + d3/s3 = 6 ms + 40 ms = 46 ms` 

#### P12 一台分组交换机接收到一个分组并决定将该分组应当转发的出链路。当某分组到达时，另一个分组正在该出链路上被发送到一半，还有 4 个其他分组正等待传输。这些分组以到达的次序传输。假定所有分组是 1500 字节并且链路速度是 2 Mbps。该分组的排队时延是多少？在更一般的情况下，当所有分组的长度是 L, 传输速率是 R, 当前正在传输的分组已经传输了 x 比特，并且已经在队列中有 n 个分组，其排队时延是多少？

> `T = (750 x 8 + 4 x 1500 x 8) / (2 x 10^6) = 0.027 s = 27 ms`
> 
> `T = (L - x + n x L) / R = [(n + 1) x L - x] / R`

#### P13 A. 假定有 N 个分组同时到达一条当前没有分组传输或排队的链路。每个分组长为 L, 链路传输速率为 R。对 N 个分组而言，其平均排队时延是多少？

> 第一个分组 `d_queue1 = 0`
> 
> 第二个分组 `d_queue2 = L/R`
> 
> 第三个分组 `d_queue3 = 2 x L/R`
> 
> 第 N 个分组 `d_queueN = (N - 1) x L/R`
> 
> 综上，N 个分组的总排队时延为 `L/R x (1 + 2 + 3 + ... + N - 1) = N x L x (N - 1) / (2 x R)`
> 
> 所以，其平均排队时延 `L x (N - 1) / (2 x R)`

#### P14 考虑路由器缓存中的排队时延。令 I 表示流量强度；即 I = La/R。假定排队时延的形式为 IL/R(1-I), 其中 I < 1。
#### a. 写出总时延，即排队时延加上传输时延
#### b. 以 L/R 为函数画出总时延的图

> `T_delay = I x L/R x (1 - I) + L/R = (L/R) / (1 - I)`
> 
> 令 `L/R = x`，则 `T_delay = x / (1 - a x x)`
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p14.png)

#### P15 令 a 表示在一条链路上分组的到达率（以分组/秒计）, 令 u 表示一条链路上分组的传输率（以分组/秒计）。基于上述习题中推到处的总延时公示（即排队时延加传输时延）, 推导出以 a 和 u 表示的总时延公示。

> `u = R/L`
> 
> `I = La/R = a/u`
> 
> `T_delay = 1 / (u - a)`

#### P16 考虑一台路由器缓存前面的一条出链路。在这个习题中，将使用李特尔公式，这是排队论中的一个著名公式。令 N 表示在缓存中的分组加上被传输的分组的平均数。令 a 表示到达链路的分组速率。令 d 表示一个分组经历的平均总延时（即排队时延加传输时延）。李特尔公式是 N = a x d。假定该缓存平均包含 10 个分组，并且平均分组排队时延是 10 ms。该链路的传输速率是 100 分组/秒。使用李特尔公式，在没有丢包的情况下，平均分组到达率是多少？

> `N = 10 + 1 = 11`
> 
> `传输速率是每秒 100 个分组，那么每个分组耗时 1/100 秒 = 0.01 s `
> `a = N/d = 11 / (0.01 + 0.01) = 11 / 0.02 = 550 分组/s`

#### P17 a. 对于不同的处理速率、传输速率和传播时延，给出 1.4.3 节中式（1-2）的一般表达式。
#### b. 重复（a）,不过此时假定在每个结点有平均排队延时 d_queue

>
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p17.1.png)
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p17.2.png)

#### P18 在一天的 3 个不同小时内，在同一个大路上的源和目的地之间执行 Traceroute。
#### a. 在这 3 个小时的每个小时中，求出往返时延的均值和方差。
#### b. 在这 3 个小时的每个小时中，求出路径上的路由器数量。在这些时段中，该路径发生变化了吗？
#### c. 试图根据源到目的地 Traceroute 分组通过的情况，辨明 ISP 网络的数量。具有类似名字和 / 或类似的 IP 地址的路由器应当被认为是同一个 ISP 的一部分。在你的实验中，在相邻的 ISP 间的对等接口处出现最大的时延了吗？
#### d.对位于不同大陆上的源和目的地重复上述内容。比较大陆内部和大陆之间的这些结果。

#### P19 a. 访问站点 www.traceroute.org，并从法国两个不同的城市向位于美国的相同的目的主机执行 Traceroute。在这两个 Traceroute 中，有多少条链路是相同的？大西洋沿岸国家的链路相同吗？
#### b. 重复（a）,但此时选择位于法国的一个城市和位于德国的另一个城市。
#### c. 在美国挑选一个城市，然后向位于中国的两个不同城市的主机执行 Traceroute。在这两次 Traceroute 中有多少条链路是相同的？在到达中国前这两个 Traceroute 分开了吗？

#### P20 考虑对应于图 1-20b 吞吐量的例子。现在假定有 M 对客户-服务器而不是 10 对。用 Rs、Rc 和 R 分别表示服务器链路、客户链路和网络链路的速率。假设所有的其他链路都有充足容量，并且除了由这 M 对客户-服务器产生的流量外，网络中没有其他流量。推导出由 Rs、Rc、R 和 M 表示的通用吞吐量表达式。

> 吞吐量为 : `min{ Rs, Rc, R/M }`

#### P21 考虑图 1-19b。现在假定在服务器和客户之间有 M 条路径。任两条路径都不共享任何链路。路径 k(k = 1, ..., M) 是由传输速率为 R1k、R2k ...、RNk 的 N 条链路组成。如果服务器仅能够使用一条路径向客户发送数据，则该服务器能够取得的最大吞吐量是多少？如果该服务器能够使用所有 M 条路径发送数据，则该服务器能够取得的最大吞吐量是多少？

> 
> 仅使用一条路径发送数据，能够取得的最大吞吐量为 : `max{ min{R11, ... RN1 }, min{R12, ... RN2}, ... min{RN1, ... RNN} }`
> 
> 
> 使用所有 M 条路径发送数据，能取得的最大吞吐量为 : `Sum{ min{R11, ... RN1 }, min{R12, ... RN2}, ... min{RN1, ... RNN} }`

#### P22 考虑图 1-19b。假定服务器与客户之间的每条链路的丢包概率为 p, 且这些链路的丢包率是独立的。一个（由服务器发送的）分组成功地被接收方收到的概率是多少？如果在服务器到客户的路径上分组丢失了，则服务器将重传该分组。平均来说，为了使客户成功地接收到该分组，服务器将要重传该分组多少次？

> N 条链路，一个分组成功被接收方收到的概率是 `C(N,N) x (1 - p)^N x p^0 = (1 - p)^N`
> 
> 该问题是一个几何分布模型："在 n 次伯努利试验中，试验 k 次才得到第一次成功的机率"，几何分布的期望是 `1/p` (p 为实验成功的概率)。
> 
> 所以为了使客户成功接收到该分组，服务器总共需要传送分组 `1/(1 - p)` 次，也就是说需要重传 `1/(1 - p) - 1` 次。

#### P23 考虑图 1-19a。假定我们知道沿着从服务器到客户的路径的瓶颈链路是速率为 Rs bps 的第一段链路。假定我们从服务器向客户发送紧接着的一对分组，且沿这条路径没有其他流量。假定每个分组的长度为 L 比特，两条链路具有相同的传播时延 `d_prop`
#### a. 在目的地，分组的到达间隔时间有多大？也就是说，从第一个分组的最后一个比特到达到第二个分组最后一个比特到达所经历的时间有多长？
#### b. 现在假定第二段链路是瓶颈链路（即 Rc < Rs ）。第二个分组在第二段链路输入队列中排队是可能的吗？请解释原因。现在假定服务器在发送第一个分组 T 秒之后再发送第二个分组。为确保在第二段链路之前没有排队，T 必须要有多长？试解释原因。

>
> a.
> 
> 当第一个分组被推上链路经过了 `L/Rs`，第二个分组被推上链路经过了 `L/Rs`，此时第一个分组已经传送了 `L/Rs` 秒，因此最终到达的时间间隔为 `L/Rs` 秒。
> 
> b.
> 
> 第二个分组传送到路由器的输出队列中所需时间 `T1 = L/Rs + L/Rs + d_prop`
> 
> 第一个分组最后一个比特离开路由器的输出队列所需时间为 `T2 = L/Rs + d_prop + L/Rc`
> 
> `T2 - T1 = L/Rc - L/Rs > 0`，因此第二个分组会在第一个分组离开输出队列前追上它，所以一定会排队。
> 
> 如果需要按照一定时间间隔来发送两个分组 `T1 = L/Rs + L/Rs + d_prop + T`
> 
> 令 `T2 - T1 <= 0` 则 `T <= L/Rc - L/Rs` 








	    
	
