#### P1  设计并描述在自动柜员机和银行的中央计算机之间使用的一种应用层协议。你的协议应当允许验证用户卡和口令，查询账目结算（这些都在中央计算机系统中进行维护），支取账目（即向用户支付钱），你的协议实体应当能够处理取钱时账目中钱不够的常见问题。通过列出自动柜员机和银行中央计算机在报文传输和接收过程中交换的报文和采取的动作来定义你的协议。使用类似于图 1-2 所示的图，拟定在简单无差错取钱情况下该协议的操作。明确地阐述在该协议中关于底层端到端运输服务所作的假设。


	Request
	    Command : xxxx
	    Parameter : xxx
	
	Response
	    ClientOpResult : xxx
	    ATMOp : xxx
	    Message : xxx
	
	
	        ATM                                                  Bank
	----------------------------------------------------------------------------------
	Command : WithDrawMoney
	Parameter : NULL    ---------------------->
	
	                    <---------------------- OpResult : OK
	                                            Message : Enter Your Name And Password
	                                            ATMOp : DisplayMessage | ReadInput
	Command : InputNameAndPassword
	Parameter : Hanson&123 -------------------> 
	                                            OpResult : Ok
	                                            Message : Check Success, Please Enter Amount
	                                            ATMOp : DisplayMessage | ReadInput
	                    <----------------------
	Command : InputAmount
	Parameter : 1000    ----------------------> 
	                                            OnResult : OK
	                                            Message : Enough, Here you are, Bye
	                                            ATMOp : DisplayMessage | Counting
	
	
	
	        ATM                                                  Bank
	----------------------------------------------------------------------------------
	Command : WithDrawMoney
	Parameter : NULL    ---------------------->
	
	                    <---------------------- OpResult : OK
	                                            Message : Enter Your Name And Password
	                                            ATMOp : DisplayMessage | ReadInput
	Command : InputNameAndPassword
	Parameter : Hanson&123 -------------------> 
	                                            OpResult : Ok
	                                            Message : Check Success, Please Enter Amount
	                                            ATMOp : DisplayMessage | ReadInput
	                    <----------------------
	Command : InputAmount
	Parameter : 1000    ----------------------> 
	                                            OnResult : Fail
	                                            Message : Not Enough, Bye
	                                            ATMOp : DisplayMessage | Exit
	                                            

#### P2 式 (1-1) 给出了经传输速率为 R 的 N 段链路发送长度 L 的一个分组的端到端时延。对于经过 N 段链路连续发送 P 个这样的分组，一般化地表示出这个公式。

> T = (N + P - 1) / R
> 
> N * L / R 秒后，第一个分组到达目的主机，此时第二个分组到达了最后一个路由，又经过 L / R 秒后，第二个分组到达目的主机，以此类推。

#### P3 考虑一个应用程序以稳定的速率传输数据（例如，发送方每 k 个时间单元产生一个 N 比特的数据单元，其中 k 较小且固定）。另外，当这个应用程序启动时，它将连续运行相当长的一段时间。回答下列问题，简要论述你的回答：
##### a. 是分组交换还是电路交换更为适合这种应用，为什么？
##### b. 假定使用了分组交换网，并且该网中的所有流量都来自如上所述的这种应用程序。此外，假定该应用程序数据传输速率的总和小于每条链路的各自容量。需要某种形式的拥塞控制吗？为什么？

> a.
> 
> 电路交换更适合这种应用；
> 
> *	 发送方速率恒定，即发送方不会闲置带宽
> *	 发送方速率稳定且没有突发性质的分组，即使用不会超出预置带宽
> * 程序启动后将运行相当长的一段时间，即启动预分配电路和资源的时间被运行时间分摊
> 
> b.
> 
> 不需要；
> 
> * 发送方传输速率的总和小于每条链路的各自容量，所以流量强度小于 1，即输出队列长度不会无界增加
> * 假设发送速率为 L 分组/s，传输速率为 R 分组/s，每隔 L/R 秒发送 1 分组数据，那么每个分组将没有排队时延，假如每隔 N * L/R （**题目已经说了 k  较小，如果 k 很大，因为现实世界输出缓存有容量限制，那么可能一开始就有丢包**）秒发送 N 分组数据，虽然除了第一个分组外每个分组都有一定的排队时延，但是在 N * L/R 秒内这些分组将全部被推上下一条链路而不会让队列长度继续增加，所以不会出现丢包现象。
> 

#### P4 考虑在图 1-13 中的电路交换网。回想在每条链路上有 4 条链路，以顺时针方向标记四台交换机 A、B、C 和 D。
#### a. 在该网络中，任何时候能够进行同时连接的最大数量是多少？
#### b. 假定所有连接位于交换机 A 和 C 之间。能够进行同时连接的最大数量是多少？
#### c. 假定我们要在交换机 A 和 C 之间建立 4 条连接，在交换机 B 和 D 之间建立另外 4 条连接。我们能够让这些呼叫通过这 4 条链路建立路由以容纳所有这 8 条连接吗？

> a.
> 
> ~~8~~
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p4.1.png)
> 
> 由上述图表示，任何时候能够同时进行连接的数量是 16 个。
> 
> b.
> 
> ~~4~~
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p4.2.png)
> 
> 由上述图表示，A 和 C 之间能够进行同时连接的最大数量是 8
> 
> c.
> 
> ~~不能~~
> 
> 能
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/01%20计算机网络和因特网/images/p4.3.png)
> 由上述图表示




	    
	
